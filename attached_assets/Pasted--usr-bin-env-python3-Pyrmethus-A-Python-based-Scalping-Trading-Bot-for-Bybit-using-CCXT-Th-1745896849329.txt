#!/usr/bin/env python3

"""Pyrmethus - A Python-based Scalping Trading Bot for Bybit using CCXT.

This bot implements a trading strategy based on Supertrend indicators,
volume spikes, and order book pressure for perpetual swap markets on Bybit (V5 API).
It uses environment variables for configuration and Termux for optional SMS notifications.

Strategy Overview:
- Utilizes two Supertrend indicators (short and long periods) for trend confirmation.
  NOTE: Uses a stateless estimation method for Supertrend, which may differ significantly
        from stateful implementations (e.g., TradingView). Verify behavior carefully
        and consider using a stateful library (like pandas-ta) for production use.
- Filters entry signals with a volume spike check (recent vs. longer-term average).
- Employs order book pressure (bid/ask volume imbalance) as an additional entry filter.
- Calculates position size based on fixed fractional risk per trade and ATR-based stop loss.
- Places market orders with integrated Stop Loss and Take Profit using Bybit V5 API features.
- Handles position reversals by closing the existing position before opening the opposite one,
  including a short wait time and price refresh.
- Includes robust error handling, retry mechanisms for API calls, configurable logging with colors,
  and exchange health checks.

Disclaimer: Trading involves significant risk. Use this bot at your own discretion.
Ensure thorough backtesting and testing in dry run mode before deploying with real capital.
The authors are not liable for any financial losses incurred.
"""

import contextlib
import logging
import math # Added for calculations like log10
import os
import subprocess  # For termux check
import sys
import time
import traceback  # For detailed error logging
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum
from typing import Any

# Third-party libraries
try:
    import ccxt
    from colorama import Back, Fore, Style, init
    from dotenv import load_dotenv

    # For specific retry logic on network connection errors
    from urllib3.exceptions import MaxRetryError, NewConnectionError
    from urllib3.exceptions import TimeoutError as Urllib3TimeoutError
except ImportError:
    print(
        "Error: Required libraries (ccxt, colorama, python-dotenv, urllib3) are not installed.",
        file=sys.stderr,
    )
    print("Please install them using: pip install ccxt colorama python-dotenv urllib3", file=sys.stderr)
    sys.exit(1)


# --- Initialize Colorama ---
# Enables cross-platform colored terminal output. Resets automatically.
init(autoreset=True)

# --- Load Environment Variables ---
# Load secrets and configuration from a .env file if present in the current directory or parent directories.
# verbose=True logs path if found, override=False prevents overwriting existing env vars
if load_dotenv(verbose=False, override=False): # Changed verbose to False for cleaner startup
    pass # Logger not ready yet, print confirmation later if needed
else:
    pass # Logger not ready yet, print warning later if needed


# --- Constants ---
class Side(Enum):
    """Represents the side of an order to be placed."""

    BUY = "buy"
    SELL = "sell"


class PositionSide(Enum):
    """Represents the side of an existing position."""

    LONG = "long"
    SHORT = "short"
    NONE = "none"  # Represents no open position


# Standard OHLCV structure indices for clarity and reduced errors
OHLCV_SCHEMA = ["timestamp", "open", "high", "low", "close", "volume"]
OHLCV_INDEX = {name: i for i, name in enumerate(OHLCV_SCHEMA)}

# Indicator/Helper Function Parameters (Default values)
DEFAULT_VOLUME_SHORT_PERIOD = 5  # Lookback for recent volume average
DEFAULT_VOLUME_LONG_PERIOD = 20  # Lookback for longer-term volume average
DEFAULT_ORDER_BOOK_DEPTH = 10  # Number of levels to fetch for order book pressure
DEFAULT_API_RETRY_DELAY = 5  # Seconds between retries for transient API errors
DEFAULT_MAX_API_RETRIES = 3  # Max retries for API calls like order placement
DEFAULT_POSITION_CLOSE_WAIT_SECONDS = (
    3  # Wait time after closing before opening reverse position
)
DEFAULT_CONSECUTIVE_ERROR_LIMIT = (
    5  # Stop bot after this many consecutive main loop errors
)
DEFAULT_MINIMUM_SLEEP_SECONDS = (
    1  # Minimum sleep time in main loop to prevent busy-waiting
)
DEFAULT_SYMBOL_RAW = (
    "BTC/USDT"  # Default symbol if none provided (user-friendly format)
)
DEFAULT_SYMBOL_API = "BTCUSDT"  # Default API formatted symbol (e.g., for Bybit V5)

# Small tolerance for floating point comparisons (e.g., checking for zero, comparing prices)
FLOAT_TOLERANCE = 1e-9


# --- Configuration ---
@dataclass
class Config:
    """Holds the application configuration, loaded from environment variables.

    Attributes are initialized with defaults and overridden by environment variables
    or user input where applicable. Includes validation logic.
    """

    # API Credentials (Loaded from env)
    bybit_api_key: str | None = field(init=False, default=None)
    bybit_api_secret: str | None = field(init=False, default=None)

    # Trading Parameters
    symbol: str = field(
        init=False, default=DEFAULT_SYMBOL_API
    )  # Final API format (e.g., BTCUSDT)
    timeframe: str = field(init=False, default="1m")
    leverage: float = field(init=False, default=10.0)
    risk_per_trade: float = field(init=False, default=0.01)  # e.g., 0.01 = 1% of equity
    sl_atr_mult: float = field(
        init=False, default=1.5
    )  # Stop Loss distance = ATR * sl_atr_mult
    tp_atr_mult: float = field(
        init=False, default=2.0
    )  # Take Profit distance = ATR * tp_atr_mult

    # Indicator Parameters
    short_st_period: int = field(
        init=False, default=7
    )  # Period for the short Supertrend
    long_st_period: int = field(
        init=False, default=14
    )  # Period for the long Supertrend
    st_multiplier: float = field(
        init=False, default=2.0
    )  # Multiplier for ATR in Supertrend calculation
    volume_spike_threshold: float = field(
        init=False, default=1.5
    )  # Ratio: short_avg_vol / long_avg_vol must exceed this
    ob_pressure_threshold: float = field(
        init=False, default=0.7
    )  # Bid pressure ratio must exceed this for LONG signal (BidVol / TotalVol)
    # Ask pressure must exceed this for SHORT signal (AskVol / TotalVol > T => BidVol / TotalVol < 1-T)

    # Bot Operation Settings
    dry_run: bool = field(
        init=False, default=False
    )  # If True, no real orders are placed
    logging_level: str = field(
        init=False, default="INFO"
    )  # Logging verbosity (DEBUG, INFO, WARNING, ERROR, CRITICAL)
    loop_sleep_seconds: int = field(
        init=False, default=60
    )  # Base sleep time between trading cycles

    # SMS Notification Settings (via Termux)
    sms_enabled: bool = field(init=False, default=False)  # Enable SMS notifications
    sms_recipient_number: str | None = field(
        init=False, default=None
    )  # Phone number to send SMS to

    # Internal fields
    _termux_sms_available: bool = field(
        init=False, default=False
    )  # Internal flag set by _check_sms_capabilities
    _raw_symbol: str = field(
        init=False, default=DEFAULT_SYMBOL_RAW
    )  # Stores the user-provided or raw env symbol format

    def _parse_bool(self, env_var_name: str, default: bool) -> bool:
        """Safely parses a boolean environment variable (case-insensitive)."""
        env_var = os.getenv(env_var_name)
        if env_var is None:
            return default
        return env_var.strip().lower() in ("true", "1", "yes", "y", "on")

    def _parse_float(self, env_var_name: str, default: float) -> float:
        """Safely parses a float environment variable with warning on failure."""
        env_var = os.getenv(env_var_name)
        try:
            return float(env_var) if env_var is not None else default
        except (ValueError, TypeError):
            # Log warning only if logger is available and level allows
            try:
                logger.warning(f"Could not parse '{env_var_name}' value '{env_var}'. Using default: {default}")
            except NameError: # Logger not yet defined
                print(f"Warning: Could not parse '{env_var_name}' value '{env_var}'. Using default: {default}", file=sys.stderr)
            return default

    def _parse_int(self, env_var_name: str, default: int) -> int:
        """Safely parses an integer environment variable with warning on failure."""
        env_var = os.getenv(env_var_name)
        try:
            return int(env_var) if env_var is not None else default
        except (ValueError, TypeError):
            try:
                logger.warning(f"Could not parse '{env_var_name}' value '{env_var}'. Using default: {default}")
            except NameError:
                print(f"Warning: Could not parse '{env_var_name}' value '{env_var}'. Using default: {default}", file=sys.stderr)
            return default

    def _format_symbol(self, raw_symbol: str) -> str:
        """Formats a raw symbol (e.g., 'BTC/USDT', 'ETH/USDT:USDT') to Bybit V5 API format (e.g., 'BTCUSDT').
        Handles common variations and removes ':USDT' if present. Returns uppercase.
        Uses default if formatting fails.
        """
        if not isinstance(raw_symbol, str) or not raw_symbol:
            print(f"Warning: Invalid raw symbol input '{raw_symbol}'. Using default: {DEFAULT_SYMBOL_RAW} -> {DEFAULT_SYMBOL_API}", file=sys.stderr)
            self._raw_symbol = DEFAULT_SYMBOL_RAW
            return DEFAULT_SYMBOL_API

        try:
            # Remove potential contract type suffix like ':USDT' first
            symbol_cleaned = raw_symbol.strip().upper().split(":")[0]
            # Remove the slash
            api_symbol = symbol_cleaned.replace("/", "")
            if not api_symbol:  # Check if result is empty after replacements
                raise ValueError("Symbol became empty after formatting.")
            # Basic sanity check for common crypto pairs (e.g., at least 4 chars like BTCUSD)
            if len(api_symbol) < 4:
                 raise ValueError(f"Formatted symbol '{api_symbol}' seems too short.")
            return api_symbol
        except (ValueError, AttributeError, IndexError) as e:
            print(f"Warning: Failed to format symbol '{raw_symbol}': {e}. Using default: {DEFAULT_SYMBOL_RAW} -> {DEFAULT_SYMBOL_API}", file=sys.stderr)
            self._raw_symbol = DEFAULT_SYMBOL_RAW  # Reset raw symbol as well
            return DEFAULT_SYMBOL_API

    def load_and_validate(self, user_symbol_override: str | None = None) -> None:
        """Loads values from environment variables, applies user symbol override, validates configuration,
        and checks SMS capabilities.

        Args:
            user_symbol_override: Symbol provided by user input, overrides env var if present.

        Raises:
            ValueError: If critical configuration validation fails.
        """
        self.bybit_api_key = os.getenv("BYBIT_API_KEY")
        self.bybit_api_secret = os.getenv("BYBIT_API_SECRET")

        # Determine symbol source: User Input > Environment Variable > Default
        raw_symbol_source = user_symbol_override or os.getenv(
            "SYMBOL", self._raw_symbol
        )
        self._raw_symbol = raw_symbol_source # Store the raw format used
        self.symbol = self._format_symbol(self._raw_symbol) # Format to API standard

        # Load other parameters using parsing helpers
        self.timeframe = os.getenv("TIMEFRAME", self.timeframe)
        self.leverage = self._parse_float("LEVERAGE", self.leverage)
        self.risk_per_trade = self._parse_float("RISK_PER_TRADE", self.risk_per_trade)
        self.sl_atr_mult = self._parse_float("SL_ATR_MULT", self.sl_atr_mult)
        self.tp_atr_mult = self._parse_float("TP_ATR_MULT", self.tp_atr_mult)
        self.short_st_period = self._parse_int("SHORT_ST_PERIOD", self.short_st_period)
        self.long_st_period = self._parse_int("LONG_ST_PERIOD", self.long_st_period)
        self.st_multiplier = self._parse_float("ST_MULTIPLIER", self.st_multiplier)
        self.volume_spike_threshold = self._parse_float(
            "VOLUME_SPIKE_THRESHOLD", self.volume_spike_threshold
        )
        self.ob_pressure_threshold = self._parse_float(
            "OB_PRESSURE_THRESHOLD", self.ob_pressure_threshold
        )
        self.dry_run = self._parse_bool("DRY_RUN", self.dry_run)
        self.logging_level = os.getenv("LOGGING_LEVEL", self.logging_level).upper()
        self.sms_enabled = self._parse_bool("SMS_ENABLED", self.sms_enabled)
        self.sms_recipient_number = os.getenv("SMS_RECIPIENT_NUMBER")
        self.loop_sleep_seconds = self._parse_int(
            "LOOP_SLEEP_SECONDS", self.loop_sleep_seconds
        )

        # --- Validation ---
        errors = []
        # Critical Validations (will raise ValueError)
        if not self.dry_run and (not self.bybit_api_key or not self.bybit_api_secret):
            errors.append(
                "CRITICAL: BYBIT_API_KEY and BYBIT_API_SECRET must be set in .env or environment when DRY_RUN is False."
            )
        if self.leverage <= FLOAT_TOLERANCE:
            errors.append(f"CRITICAL: LEVERAGE ({self.leverage}) must be positive.")
        if not (FLOAT_TOLERANCE < self.risk_per_trade < 1.0):
            errors.append(
                f"CRITICAL: RISK_PER_TRADE ({self.risk_per_trade}) must be between 0 (exclusive) and 1 (exclusive)."
            )
        if self.sl_atr_mult <= FLOAT_TOLERANCE:
            errors.append(
                f"CRITICAL: SL_ATR_MULT ({self.sl_atr_mult}) must be positive."
            )
        if self.tp_atr_mult <= FLOAT_TOLERANCE:
            errors.append(
                f"CRITICAL: TP_ATR_MULT ({self.tp_atr_mult}) must be positive."
            )
        if self.short_st_period <= 0:
            errors.append(
                f"CRITICAL: SHORT_ST_PERIOD ({self.short_st_period}) must be positive."
            )
        if self.long_st_period <= 0:
            errors.append(
                f"CRITICAL: LONG_ST_PERIOD ({self.long_st_period}) must be positive."
            )
        if self.st_multiplier <= FLOAT_TOLERANCE:
            errors.append(
                f"CRITICAL: ST_MULTIPLIER ({self.st_multiplier}) must be positive."
            )
        if self.volume_spike_threshold <= FLOAT_TOLERANCE:
            errors.append(
                f"CRITICAL: VOLUME_SPIKE_THRESHOLD ({self.volume_spike_threshold}) must be positive."
            )
        if not (FLOAT_TOLERANCE < self.ob_pressure_threshold < 1.0):
            errors.append(
                f"CRITICAL: OB_PRESSURE_THRESHOLD ({self.ob_pressure_threshold}) must be between 0 (exclusive) and 1 (exclusive)."
            )
        if self.loop_sleep_seconds < DEFAULT_MINIMUM_SLEEP_SECONDS:
            errors.append(
                f"CRITICAL: LOOP_SLEEP_SECONDS ({self.loop_sleep_seconds}) must be at least {DEFAULT_MINIMUM_SLEEP_SECONDS}."
            )
        if self.logging_level not in logging._nameToLevel:
            # Log error message before potentially raising ValueError
            print(f"CRITICAL: Invalid LOGGING_LEVEL: {self.logging_level}. Choose from DEBUG, INFO, WARNING, ERROR, CRITICAL.", file=sys.stderr)
            errors.append(
                f"Invalid LOGGING_LEVEL: {self.logging_level}. Choose from DEBUG, INFO, WARNING, ERROR, CRITICAL."
            )
        # Check SMS settings if enabled (Warning, not critical failure)
        if self.sms_enabled and not self.sms_recipient_number:
            print("Warning: SMS_ENABLED is True, but SMS_RECIPIENT_NUMBER is not set. Disabling SMS.", file=sys.stderr)
            self.sms_enabled = False  # Disable if number missing

        if errors:
            # Print all critical errors before raising exception
            print("\n--- Configuration Errors ---", file=sys.stderr)
            for error_msg in errors:
                print(f"- {error_msg}", file=sys.stderr)
            print("----------------------------", file=sys.stderr)
            raise ValueError(
                "Critical configuration validation failed. Please check errors above and your .env file or environment variables."
            )

        # --- SMS Setup/Check ---
        self._check_sms_capabilities()

    def _check_sms_capabilities(self) -> None:
        """Checks for Termux SMS command availability if SMS is enabled."""
        if self.sms_enabled and self.sms_recipient_number:
            try:
                # Use 'command -v' for POSIX standard check, more reliable than which
                # Capture stderr to suppress "not found" messages from appearing on console
                # Increased timeout for potentially slow Termux API interaction
                subprocess.check_output(
                    ["command", "-v", "termux-sms-send"],
                    stderr=subprocess.DEVNULL,
                    timeout=10,
                )
                self._termux_sms_available = True
                # Log success only if logger is available
                try:
                    logger.info("Termux 'termux-sms-send' command found. SMS enabled.")
                except NameError:
                     print("Info: Termux 'termux-sms-send' command found. SMS enabled.")
            except (subprocess.CalledProcessError, FileNotFoundError):
                print("Warning: 'termux-sms-send' command not found. Disabling SMS.", file=sys.stderr)
                self.sms_enabled = False
                self._termux_sms_available = False
            except subprocess.TimeoutExpired:
                print("Warning: Timeout checking for 'termux-sms-send' command. Disabling SMS.", file=sys.stderr)
                self.sms_enabled = False
                self._termux_sms_available = False
            except Exception as e:
                print(f"Warning: Error checking for 'termux-sms-send': {e}. Disabling SMS.", file=sys.stderr)
                self.sms_enabled = False
                self._termux_sms_available = False
        elif self.sms_enabled and not self.sms_recipient_number:
            # This case is handled by validation, but good to have a log here too.
            # Message already printed during validation.
            self.sms_enabled = False
        else:
            # SMS not enabled in config, do nothing.
            pass


# --- Prompt for Symbol ---
# Use the raw default symbol in the prompt for user familiarity
print(Fore.CYAN + Style.BRIGHT + "\n--- Pyrmethus Bot Configuration ---" + Style.RESET_ALL)
requested_symbol_raw = input(
    Fore.MAGENTA
    + Style.BRIGHT
    + f"Enter trading symbol (e.g., BTC/USDT, ETHUSDT) or press Enter for default ({DEFAULT_SYMBOL_RAW}): "
    + Style.RESET_ALL
).strip()
# Use default if user presses Enter without typing anything
user_symbol_input = requested_symbol_raw if requested_symbol_raw else None
if not user_symbol_input:
    print(f"Using default symbol: {DEFAULT_SYMBOL_RAW}")

# --- Initialize Config ---
try:
    config = Config()
    config.load_and_validate(user_symbol_override=user_symbol_input)
except ValueError as e:
    # Specific errors already printed during validation
    print(f"\n{Fore.RED}{Style.BRIGHT}Configuration Error: {e}{Style.RESET_ALL}")
    sys.exit(1)
except Exception as e:
    # Attempt to log traceback if logger is somehow available, otherwise just print
    print(f"\n{Fore.RED}{Style.BRIGHT}Unexpected Configuration Error:{Style.RESET_ALL}")
    traceback.print_exc()
    sys.exit(1)


# --- Logging Setup ---
# Configure logging after config is loaded and validated
log_level_int = getattr(logging, config.logging_level, logging.INFO)

# Define formatters
# Console Formatter (with color placeholders, applied later)
console_formatter = logging.Formatter(
    "%(log_color)s%(asctime)s - %(levelname)-8s - [%(filename)s:%(lineno)d] - %(message)s%(reset)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
# File Formatter (no color codes)
file_formatter = logging.Formatter(
    "%(asctime)s - %(levelname)-8s - [%(filename)s:%(lineno)d] - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


# Create a custom handler to add colors based on log level
class ColorizingStreamHandler(logging.StreamHandler):
    """Custom stream handler that adds color codes to log messages based on level."""

    LEVEL_COLORS = {
        logging.DEBUG: Style.DIM + Fore.BLUE,
        logging.INFO: Fore.CYAN,
        logging.WARNING: Fore.YELLOW,
        logging.ERROR: Fore.RED,
        logging.CRITICAL: Fore.RED + Style.BRIGHT + Back.WHITE,
    }
    RESET_CODE = Style.RESET_ALL

    def format(self, record):
        """Formats the record, adding color codes and highlighting specific keywords."""
        record.log_color = self.LEVEL_COLORS.get(
            record.levelno, Fore.WHITE
        )  # Default to white if level unknown
        record.reset = self.RESET_CODE
        # Special highlighting for specific message types
        msg = super().format(record)  # Format first to get the full message string
        # Apply keyword highlighting after standard formatting
        # Use bright yellow for actions
        msg = msg.replace(
            "ACTION:", Fore.YELLOW + Style.BRIGHT + "ACTION:" + record.log_color
        )
        # Use bright magenta for dry run related messages
        msg = msg.replace(
            "DRY RUN:", Fore.MAGENTA + Style.BRIGHT + "DRY RUN:" + record.log_color
        )
        msg = msg.replace(
            "Simulating", Fore.MAGENTA + Style.BRIGHT + "Simulating" + record.log_color
        )
        msg = msg.replace(
            "Simulated", Fore.MAGENTA + Style.BRIGHT + "Simulated" + record.log_color
        )
        # Ensure critical messages retain their critical color highlight (already handled by LEVEL_COLORS)
        # Use bright red for explicit errors/failures
        msg = msg.replace(
            "FAILED", Fore.RED + Style.BRIGHT + "FAILED" + record.log_color
        )
        msg = msg.replace(
            "Failed", Fore.RED + Style.BRIGHT + "Failed" + record.log_color
        )
        msg = msg.replace(
            "CRITICAL", Fore.RED + Style.BRIGHT + "CRITICAL" + record.log_color
        )
        msg = msg.replace(
            "FATAL", Fore.RED + Style.BRIGHT + "FATAL" + record.log_color
        )

        return msg


# File Handler (ensure it can write to the file)
log_filename = "pyrmethus_trading_bot.log" # More descriptive filename
file_handler = None  # Initialize to None
try:
    # Use 'a' for append mode, ensure encoding is UTF-8
    file_handler = logging.FileHandler(log_filename, mode="a", encoding="utf-8")
    file_handler.setFormatter(file_formatter)
except OSError as e:
    print(f"Warning: Could not open log file '{log_filename}' for writing: {e}. File logging disabled.", file=sys.stderr)
    # Optionally, disable file logging or exit
    file_handler = None

# Console Handler (using custom color handler)
console_handler = ColorizingStreamHandler(sys.stdout)
console_handler.setFormatter(console_formatter)

# Configure Root Logger
# Clear existing handlers if any were added previously (e.g., by basicConfig in libraries)
root_logger = logging.getLogger()
if root_logger.hasHandlers():
    root_logger.handlers.clear()

root_logger.setLevel(log_level_int)
root_logger.addHandler(console_handler)
if file_handler:
    root_logger.addHandler(file_handler)

logger = logging.getLogger(__name__)  # Get logger for this module

# Suppress verbose logs from underlying libraries for cleaner output
logging.getLogger("ccxt.base.exchange").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)
logging.getLogger("dotenv.main").setLevel(
    logging.WARNING
)  # Silence dotenv path logging unless debug

# Log confirmation messages now that logger is configured
if load_dotenv(verbose=False, override=False):
    logger.debug(f".env file found and loaded from: {os.getenv('DOTENV_PATH', 'N/A')}")
else:
    logger.warning(".env file not found or not loaded. Ensure environment variables are set.")

logger.info(
    f"Logging configured. Level: {config.logging_level}, File: {log_filename if file_handler else 'Disabled'}"
)

if config.dry_run:
    # Use logger.warning for visibility, color handled by formatter
    logger.warning(
        "DRY RUN MODE ENABLED: No real orders will be placed. SMS notifications will be silenced."
    )
    # Ensure SMS is off in dry run, regardless of config (safer)
    if config.sms_enabled:
        logger.info("Disabling SMS notifications because DRY_RUN is enabled.")
        config.sms_enabled = False


# --- Exchange Setup ---
def setup_exchange(conf: Config) -> ccxt.Exchange | None:
    """Initializes and configures the CCXT exchange instance for Bybit (V5 API focus).
    Includes connection verification and symbol check.

    Args:
        conf: The application configuration object.

    Returns:
        A configured ccxt.Exchange instance or None if setup fails.
    """
    logger.info(
        f"✨ Initializing CCXT exchange for Bybit (ccxt version: {ccxt.__version__})..."
    )
    exchange_instance = None
    try:
        exchange_params = {
            "enableRateLimit": True,  # Crucial for respecting exchange API limits
            # "verbose": conf.logging_level == "DEBUG", # Uncomment for extremely verbose CCXT internal logging
            "options": {
                "defaultType": "swap",  # Use 'swap' for perpetual futures/swaps
                "adjustForTimeDifference": True,  # Helps mitigate clock skew issues
                # Bybit V5 specific options
                "brokerId": "PYRMETHUS",  # Optional: Identify your bot via broker ID if registered
                # Explicitly target V5 API version for clarity and future-proofing
                # Although CCXT usually defaults correctly, being explicit can help
                # 'defaultVersion': 'v5', # This might conflict with how CCXT handles unified endpoints, test carefully
                # Account type might be needed for some operations, often inferred from API key scope
                # Common Bybit account types: UNIFIED (UTA), CONTRACT (Classic Inverse/USDC), SPOT
                # Let CCXT infer or specify if needed: 'account': 'unified' or 'contract'
                'fetchPositions': 'v5', # Hint to use V5 endpoint for positions
                'fetchBalance': 'v5', # Hint to use V5 endpoint for balance
                'createOrder': 'v5', # Hint to use V5 endpoint for orders
                'fetchOrderBook': 'v5',
                'fetchOHLCV': 'v5',
                'fetchTicker': 'v5',
                # Add other V5 hints as needed based on CCXT version and Bybit API changes
            },
        }
        if not conf.dry_run:
            if not conf.bybit_api_key or not conf.bybit_api_secret:
                # This should be caught by validation, but acts as a safeguard
                logger.critical(
                    "🚫 Cannot initialize live exchange: API Key/Secret missing."
                )
                return None
            exchange_params["apiKey"] = conf.bybit_api_key
            exchange_params["secret"] = conf.bybit_api_secret
            logger.info("Initializing exchange with API keys (Live Mode).")
        else:
            logger.info("Initializing exchange without API keys (Dry Run Mode).")

        # Instantiate the exchange
        exchange_instance = ccxt.bybit(exchange_params)

        # Set sandbox mode if needed for testing (check Bybit docs for current testnet URL/setup)
        # exchange_instance.set_sandbox_mode(True) # Uncomment for Bybit testnet

        # Load markets (essential for symbol info, limits, precision)
        logger.info("📡 Loading market data... (This may take a moment)")
        # Force reload to ensure freshness, especially important on startup or re-init
        exchange_instance.load_markets(reload=True)
        logger.info(f"✅ Connected to {exchange_instance.id}. Market data loaded.")

        # --- Verify connection and symbol ---
        try:
            server_time = exchange_instance.fetch_time()
            local_time = exchange_instance.milliseconds()
            time_diff = abs(server_time - local_time)
            logger.info(
                f"🕰️ Exchange server time: {exchange_instance.iso8601(server_time)} (Difference to local: {time_diff}ms)"
            )
            if (
                time_diff > 5000
            ):  # Warn if clock skew is significant (e.g., > 5 seconds)
                logger.warning(
                    f"⚠️ Significant time difference ({time_diff}ms) between local clock and server clock. Consider system time sync (e.g., using NTP)."
                )
        except Exception as time_e:
            # Non-critical, but indicates potential connection issues
            logger.warning(
                f"⚠️ Could not verify exchange time: {time_e}. Connection might be unstable or API endpoint changed."
            )

        # Verify the configured symbol exists in the loaded markets for the correct type (swap)
        if conf.symbol not in exchange_instance.markets:
            logger.error(f"❌ Symbol '{conf.symbol}' not found on {exchange_instance.id}.")
            market_type = "Not Found"
        else:
            market_info = exchange_instance.markets[conf.symbol]
            market_type = market_info.get("type", "N/A")
            # Check if it's a swap market (includes futures, perps)
            if not market_info.get("swap", False): # CCXT often uses a boolean 'swap' flag
                 logger.error(f"❌ Symbol '{conf.symbol}' found, but it is not a SWAP/Future market (type: '{market_type}'). This bot requires perpetual swaps.")
                 market_type = f"{market_type} (Not Swap)" # Update for logging below
            else:
                 logger.info(f"✅ Symbol '{conf.symbol}' found and confirmed as SWAP market on the exchange.")
                 # Log market details if debugging is enabled
                 if conf.logging_level == "DEBUG":
                    try:
                        market_details = exchange_instance.market(conf.symbol)
                        logger.debug(f"Market details for {conf.symbol}: {market_details}")
                    except Exception as market_e:
                        logger.debug(
                            f"Could not retrieve detailed market info for {conf.symbol}: {market_e}"
                        )
                 return exchange_instance # Successful setup

        # If we reached here, the symbol check failed
        logger.error(
            "   Check symbol spelling, ensure it's a perpetual swap/future available via API, and matches the required API format (e.g., BTCUSDT, not BTC/USDT)."
        )
        # Attempt to list available swap symbols
        try:
            swap_symbols = [
                s
                for s, m in exchange_instance.markets.items()
                if m.get("swap", False) # Use the 'swap' flag
            ]
            if swap_symbols:
                 logger.info(
                    f"   Available SWAP symbols sample ({len(swap_symbols)} total): {swap_symbols[:15]}..."
                 )
                 # Attempt to find similar symbols based on the raw input
                 try:
                    base_part = (
                        conf._raw_symbol.split("/")[0].upper()
                        if "/" in conf._raw_symbol
                        else conf._raw_symbol[:3].upper()
                    )
                    # Look for symbols starting with base and ending in USDT (common pattern)
                    similar = [
                        s for s in swap_symbols if s.startswith(base_part) and s.endswith("USDT")
                    ]
                    if similar:
                        logger.info(
                            f"   Did you mean one of these USDT perpetuals? {similar[:15]}"
                        )
                 except Exception:
                    pass # Ignore errors in finding similar
            else:
                logger.warning("Could not retrieve a list of available SWAP symbols.")
        except Exception as list_e:
            logger.warning(f"Could not retrieve list of SWAP symbols: {list_e}")

        return None # Symbol check failed

    except ccxt.AuthenticationError as e:
        logger.critical(
            f"🚫 Authentication Error connecting to Bybit: {e}. Check API Key/Secret. Ensure keys have correct permissions (Trade). Exiting."
        )
        sys.exit(
            1
        )  # Exit immediately on auth error, as it's unrecoverable without user action
    except (
        ccxt.NetworkError,
        ccxt.ExchangeNotAvailable,
        NewConnectionError,
        MaxRetryError,
        Urllib3TimeoutError,
        ccxt.RequestTimeout, # Added RequestTimeout
    ) as e:
        logger.error(
            f"🕸️ Network/Connectivity error setting up exchange: {type(e).__name__} - {e}. Check internet connection, firewall, and Bybit status page."
        )
        return None  # Allow retry in the main loop
    except ccxt.ExchangeError as e:
        exchange_id_str = getattr(exchange_instance, 'id', 'Bybit') # Safer access
        logger.error(f"🏛️ Exchange setup failed for {exchange_id_str}: {e}")
        # Check for common informative errors
        if "Invalid symbol" in str(e):
            logger.error(
                "   Double-check the SYMBOL format and availability on the exchange."
            )
        return None  # Allow retry
    except Exception as e:
        logger.exception(
            f"💥 Unexpected error during exchange setup: {e}"
        )  # Log full traceback
        return None  # Allow retry


# Attempt initial exchange setup
exchange = setup_exchange(config)
if (
    exchange is None and not config.dry_run
):  # Allow dry run to potentially continue without exchange (limited functionality)
    logger.critical(
        "🛑 Failed to initialize exchange during startup. The bot cannot proceed in live mode. Exiting."
    )
    sys.exit(1)
elif exchange is None and config.dry_run:
    logger.warning(
        "⚠️ Exchange initialization failed, but continuing in DRY RUN mode. Data fetching and order placement will be simulated/skipped."
    )


# --- Set Leverage ---
def set_symbol_leverage(
    exchange_instance: ccxt.Exchange | None, symbol: str, leverage: float, conf: Config
) -> bool:
    """Sets the leverage for the specified symbol on Bybit using the V5 API.
    Assumes ISOLATED margin mode is required or already set for the symbol.

    Args:
        exchange_instance: The configured ccxt.Exchange instance (can be None for dry run).
        symbol: The market symbol (e.g., "BTCUSDT").
        leverage: The desired leverage value.
        conf: The application configuration object (for dry_run check).

    Returns:
        True if leverage was set successfully or not needed (dry run/already set), False otherwise.
    """
    if conf.dry_run:
        # Use logger.info with color handled by formatter
        logger.info(f"DRY RUN: Skipping leverage setting for {symbol} to {leverage}x.")
        return True
    if not exchange_instance:
        logger.error(
            "❌ Cannot set leverage: Exchange object is not available (initialization likely failed)."
        )
        return False

    logger.info(
        f"🔧 Attempting to set leverage for {Style.BRIGHT}{symbol}{Style.NORMAL} to {Style.BRIGHT}{leverage}x{Style.RESET_ALL} (requires Isolated Margin)..."
    )
    try:
        # Fetch market data again if needed, or rely on loaded markets
        market = exchange_instance.market(symbol)
        # Determine category (linear/inverse) - essential for V5 API
        category = "linear"  # Default assumption for USDT perps
        settle_currency = market.get("settle", "").upper()
        if market.get("inverse"):
            category = "inverse"  # Use inverse category if market info indicates it
            logger.info(
                f"Detected INVERSE contract ({settle_currency} settle) for {symbol}. Using '{category}' category."
            )
        else:
            logger.info(
                f"Detected LINEAR contract ({settle_currency} settle) for {symbol}. Using '{category}' category."
            )

        # Bybit V5 API uses unified endpoint - requires string values for leverage
        # Ensure leverage is positive and reasonable (exchange might have limits)
        if leverage <= 0:
            logger.error(f"❌ Invalid leverage value: {leverage}. Must be positive.")
            return False
        # Check exchange limits if available
        leverage_limits = market.get('limits', {}).get('leverage', {})
        max_leverage = safe_float(leverage_limits.get('max'), None)
        if max_leverage is not None and leverage > max_leverage:
            logger.error(f"❌ Requested leverage {leverage}x exceeds exchange maximum of {max_leverage}x for {symbol}.")
            return False

        leverage_str = str(
            int(leverage) if leverage.is_integer() else leverage
        )  # Format leverage as string

        params = {
            "category": category,
            "symbol": symbol,
            "buyLeverage": leverage_str,
            "sellLeverage": leverage_str,
            # Bybit V5 often requires setting margin mode simultaneously or implicitly assumes Isolated for leverage setting.
            # Trying to set leverage usually requires Isolated mode anyway.
            # If issues persist, consider explicitly setting margin mode first:
            # try:
            #     exchange_instance.set_margin_mode('isolated', symbol, {'category': category})
            #     logger.info(f"Set margin mode to ISOLATED for {symbol} ({category}).")
            # except Exception as margin_e:
            #     logger.warning(f"Could not explicitly set margin mode for {symbol}: {margin_e}")
        }
        logger.debug(
            f"Calling private_post_v5_position_set_leverage with params: {params}"
        )
        # Use the generic private_post method which CCXT maps correctly based on V5 hint
        response = exchange_instance.private_post_v5_position_set_leverage(params)
        logger.debug(
            f"Set leverage response: {response}"
        )  # Log raw response for debugging

        # Check response structure for success (Bybit V5 often returns retCode=0 on success)
        if isinstance(response, dict) and response.get("retCode") == 0:
            logger.info(
                f"✅ Leverage successfully set to {leverage}x for {symbol}. Response: {response.get('retMsg', 'OK')}"
            )
            return True
        # Specific code for "Leverage not modified" (e.g., already set)
        elif isinstance(response, dict) and response.get("retCode") in [110043, 34036]: # 34036 also seen for "leverage not modified"
            logger.info(
                f"ℹ️ Leverage for {symbol} already set to {leverage}x (or request was identical). Code: {response.get('retCode')}"
            )
            return True
        else:
            # Log unexpected response structure or failure code
            ret_code = response.get("retCode", "N/A")
            ret_msg = response.get("retMsg", "N/A")
            logger.error(
                f"❌ Failed to set leverage for {symbol}. Exchange response code: {ret_code}, message: '{ret_msg}'. Response: {response}"
            )
            # Check for common failure messages based on retMsg or codes
            if "isolated margin mode is required" in ret_msg.lower() or ret_code in [110025]: # 110025 often margin mode issue
                logger.error(
                    "   Suggestion: Ensure ISOLATED margin mode is selected for this symbol in your Bybit account settings."
                )
            elif "unified account" in ret_msg.lower() or "classic account" in ret_msg.lower() or ret_code in [10001]: # 10001 often permission/account issue
                logger.error(
                    "   Suggestion: This operation might require a Unified Trading Account (UTA) or different account type/API key permissions."
                )
            elif "position idx not match" in ret_msg.lower():
                logger.error(
                    "   Suggestion: Ensure you are in One-Way position mode if applicable (Hedge mode might cause this)."
                )
            elif "insufficient available balance" in ret_msg.lower() or ret_code in [110007]: # 110007 insufficient balance
                 logger.error(
                    "   Suggestion: Insufficient balance for the requested leverage or margin mode change."
                 )
            return False

    except ccxt.NotSupported as e:
        logger.error(
            f"❌ Setting leverage is not supported by {exchange_instance.id} for {symbol} via this method: {e}"
        )
        return False
    except ccxt.DDoSProtection as e:
        logger.warning(
            f"⏳ Rate limit hit while setting leverage for {symbol}. Will rely on existing setting. Error: {e}"
        )
        return False  # Treat as temporary failure, don't halt bot but flag the issue
    except ccxt.ExchangeError as e:
        # Check for specific informative Bybit errors based on string content or known codes
        # Some codes might be handled by the direct response check above, but catch others here.
        err_str = str(e).lower()
        err_code = getattr(e, 'code', None) # Check if ccxt parsed a code

        # Use Bybit's official error code list if possible, e.g., 110043 for "Leverage not modified"
        if "leverage not modified" in err_str or err_code in [110043, 34036] or "110043" in str(e) or "34036" in str(e):
            logger.info(f"ℹ️ Leverage for {symbol} already set to {leverage}x.")
            return True
        elif "set leverage not supported under classic account" in err_str or err_code in [10001] or "10001" in str(e):
            logger.error(
                f"❌ Cannot set leverage for {symbol}: Operation might require a Unified Trading Account (UTA) or different API key permissions. {e}"
            )
            return False
        elif "isolated margin mode is required" in err_str or "margin mode is not isolated" in err_str or "please switch to isolated margin mode" in err_str or err_code in [110025] or "110025" in str(e):
            logger.error(
                f"❌ Cannot set leverage for {symbol}: Switch to ISOLATED margin mode in Bybit's settings for this symbol first. {e}"
            )
            return False
        elif "position idx not match" in err_str:
            logger.error(
                f"❌ Cannot set leverage for {symbol}: Position index mismatch. Ensure you are in One-Way position mode if applicable. {e}"
            )
            return False
        elif "insufficient available balance" in err_str or err_code in [110007] or "110007" in str(e):
            logger.error(
                f"❌ Cannot set leverage for {symbol}: Insufficient balance for the requested leverage/margin mode change. {e}"
            )
            return False
        else:
            logger.error(f"❌ API error setting leverage for {symbol}: {e}")
            logger.debug(
                f"   Failed leverage request details: Symbol={symbol}, Leverage={leverage}, Category={category}"
            )
            return False
    except Exception as e:
        logger.exception(f"💥 Unexpected error setting leverage for {symbol}: {e}")
        return False


# Apply leverage on startup (only if not dry run and exchange is available)
if not config.dry_run and exchange:
    leverage_set_success = set_symbol_leverage(
        exchange, config.symbol, config.leverage, config
    )
    if not leverage_set_success:
        logger.warning(
            f"⚠️ Could not automatically verify or set leverage for {config.symbol} during startup."
        )
        logger.warning(
            f"   Please ensure leverage is set correctly to {config.leverage}x in the Bybit interface and margin mode is ISOLATED."
        )
        # Decide if this is critical. For risk calculation, it is.
        logger.critical(
            "🛑 Stopping bot due to inability to confirm leverage setting. Risk calculation depends on correct leverage."
        )
        sys.exit(1)


# --- Notification Service ---
sms_failure_count = 0 # Track consecutive SMS failures
MAX_SMS_FAILURES = 3 # Disable SMS after this many consecutive failures

def send_sms(message: str) -> None:
    """Sends an SMS message via Termux command if configured and available.
    Silently ignores if SMS is disabled, unavailable, or in dry run mode.
    Includes basic message sanitization and length limiting.

    Args:
        message: The text message to send.
    """
    global sms_failure_count # Allow modification of the counter

    # Check if SMS is enabled and ready *each time* in case it was disabled mid-run
    # Also ensures dry run doesn't send SMS.
    if (
        not config.sms_enabled # Checks master flag (can be disabled by errors)
        or not config._termux_sms_available # Checks if command exists
        or not config.sms_recipient_number # Checks if number is set
        # config.dry_run is checked implicitly as config.sms_enabled is set to False in dry run mode during init
    ):
        # Log truncated message only in debug to avoid cluttering console if SMS is off
        logger.debug(
            f"SMS sending skipped (Enabled={config.sms_enabled}, Available={config._termux_sms_available}, DryRun={config.dry_run}, RecipientSet={bool(config.sms_recipient_number)}). Message: {message[:70]}..."
        )
        return

    try:
        # Basic sanitization: remove characters that might break command line argument parsing.
        # Avoid complex regex, just replace common problematic chars like quotes, backticks, dollar signs, exclamation points, backslashes.
        sanitized_message = (
            message.replace('"', "'")
            .replace("`", "'")
            .replace("$", "USD")
            .replace("!", ".")
            .replace("\\", "/")
        )
        # Limit message length (standard SMS is 160 chars, but keep it shorter for safety)
        max_len = 155
        if len(sanitized_message) > max_len:
            original_len = len(sanitized_message)
            sanitized_message = sanitized_message[:max_len] + "..."
            logger.debug(
                f"SMS message truncated from {original_len} to {len(sanitized_message)} chars."
            )

        command = [
            "termux-sms-send",
            "-n",
            config.sms_recipient_number,
            sanitized_message,
        ]

        logger.info(f"📱 Attempting to send SMS to {config.sms_recipient_number}...")
        # Log command only in debug for privacy/security
        logger.debug(f"Executing SMS command: {' '.join(command)}")
        # Increased timeout, check=False to handle non-zero exit codes manually
        # Capture output to check stderr
        result = subprocess.run(
            command, capture_output=True, text=True, check=False, timeout=30
        )

        if result.returncode == 0:
            logger.info("📲 SMS sent successfully via Termux.")
            sms_failure_count = 0 # Reset failure count on success
        else:
            sms_failure_count += 1
            # Log stderr for debugging, strip whitespace
            stderr_output = (
                result.stderr.strip() if result.stderr else "No stderr output"
            )
            stdout_output = (
                result.stdout.strip() if result.stdout else "No stdout output"
            )  # Sometimes errors go to stdout
            logger.error(
                f"❌ Failed to send SMS via Termux (Attempt {sms_failure_count}/{MAX_SMS_FAILURES}). Return code: {result.returncode}. Stdout: '{stdout_output}'. Stderr: '{stderr_output}'"
            )
            # Disable SMS temporarily if it fails repeatedly
            if sms_failure_count >= MAX_SMS_FAILURES:
                logger.warning(f"Disabling SMS notifications due to {sms_failure_count} consecutive failures.")
                config.sms_enabled = False # Disable future attempts

    except FileNotFoundError:
        # This should ideally be caught during init, but handle defensively
        logger.error(
            "❌ Failed to send SMS: 'termux-sms-send' command not found. Disabling SMS for this session."
        )
        config.sms_enabled = False
        config._termux_sms_available = False
    except subprocess.TimeoutExpired:
        sms_failure_count += 1
        logger.error(
            f"❌ Failed to send SMS: Termux command timed out after 30 seconds (Attempt {sms_failure_count}/{MAX_SMS_FAILURES})."
        )
        if sms_failure_count >= MAX_SMS_FAILURES:
            logger.warning(f"Disabling SMS notifications due to {sms_failure_count} consecutive failures (timeout).")
            config.sms_enabled = False
    except Exception as e:
        sms_failure_count += 1
        logger.exception(f"💥 Failed to send SMS due to unexpected error (Attempt {sms_failure_count}/{MAX_SMS_FAILURES}): {e}")
        if sms_failure_count >= MAX_SMS_FAILURES:
            logger.warning(f"Disabling SMS notifications due to {sms_failure_count} consecutive failures (exception).")
            config.sms_enabled = False


# --- Helper Functions ---
def safe_float(value: Any, default: float = 0.0) -> float:
    """Safely converts a value to float, returning default on failure."""
    if value is None:
        return default
    try:
        # Handle potential string representations like "inf", "-inf", "nan"
        f_val = float(value)
        if math.isnan(f_val) or math.isinf(f_val):
             # logger.debug(f"Could not convert value '{value}' (type: {type(value)}) to finite float, using default {default}.")
             return default
        return f_val
    except (ValueError, TypeError):
        # Log the error only if debugging is enabled to avoid clutter
        # logger.debug(f"Could not convert value '{value}' (type: {type(value)}) to float, using default {default}.")
        return default


def fetch_ohlcv(
    exch: ccxt.Exchange | None, symbol: str, timeframe: str, limit: int
) -> list[list[int | float]] | None:
    """Fetches historical OHLCV data from the exchange with validation and dry run simulation.

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run simulation).
        symbol: The market symbol (e.g., "BTCUSDT").
        timeframe: The candle timeframe (e.g., "1m", "5m").
        limit: The maximum number of candles to fetch.

    Returns:
        A list of OHLCV lists [[ts, o, h, l, c, v], ...] sorted oldest to newest,
        or None on failure or if data is insufficient/malformed. Returns mock data if exch is None (dry run).
    """
    if not exch:
        if config.dry_run:
            logger.debug(
                f"DRY RUN: Simulating fetch_ohlcv for {symbol} ({timeframe}, limit={limit}). Returning mock data."
            )
            # Generate simple mock data: Use current time, fake prices around a base
            mock_data = []
            now_ms = int(time.time() * 1000)
            try:
                # Try to parse timeframe for interval, fallback to 1 minute
                time_interval_seconds = ccxt.Exchange.parse_timeframe(timeframe)
            except ValueError:
                logger.warning(
                    f"Could not parse timeframe '{timeframe}' for mock data generation, using 60s."
                )
                time_interval_seconds = 60
            time_interval_ms = time_interval_seconds * 1000

            # Try to get a somewhat realistic base price if possible (e.g., from config or a fixed value)
            # This is very basic, a better mock might fetch a recent ticker price once.
            base_price = 60000  # Example base price for BTCUSDT
            price_variation = base_price * 0.001  # 0.1% variation
            volume_base = 10  # Example base volume

            for i in range(limit):
                ts = now_ms - (limit - 1 - i) * time_interval_ms
                o = base_price + (i % 10 - 5) * price_variation * (1 + i*0.01) # Add slight trend
                h = o + price_variation * (1.5 + i*0.01)
                l = o - price_variation * (1.5 + i*0.01)
                c = o + (i % 3 - 1) * price_variation * (1 + i*0.01) # Close variation
                v = volume_base + (i % 20) * (volume_base * 0.5) * (1 + i*0.005) # Volume variation
                # Ensure values are positive
                o, h, l, c = max(0.01, o), max(0.01, h), max(0.01, l), max(0.01, c)
                v = max(0.0, v)
                # Ensure H >= L and C is between L and H
                h = max(h, l + FLOAT_TOLERANCE) # Ensure H is strictly > L
                c = max(min(c, h), l) # Clamp C between L and H
                o = max(min(o, h), l) # Clamp O between L and H

                mock_data.append([ts, o, h, l, c, v])
            return mock_data
        else:
            logger.error(
                "❌ Cannot fetch OHLCV: Exchange object is not available and not in dry run mode."
            )
            return None

    logger.debug(
        f"📊 Fetching up to {limit} OHLCV candles for {symbol} ({timeframe})..."
    )
    try:
        # CCXT fetch_ohlcv generally returns candles sorted oldest to newest
        # Bybit V5 might have different behavior or limits, check CCXT docs/issues if problems arise
        params = {'category': 'linear'} # Specify category for V5 linear contracts
        try:
            if exch.market(symbol).get('inverse'):
                params['category'] = 'inverse'
        except Exception: pass # Ignore if market check fails

        ohlcv = exch.fetch_ohlcv(symbol, timeframe, limit=limit, params=params)

        # Validate response
        if not ohlcv:
            logger.warning(
                f"⚠️ No OHLCV data returned for {symbol} {timeframe} (limit={limit}). Exchange might have no history or symbol/timeframe is invalid."
            )
            return None
        if not isinstance(ohlcv, list) or not all(
            isinstance(row, list) for row in ohlcv
        ):
            logger.error(
                f"❌ Unexpected OHLCV data type received for {symbol}. Expected list of lists, got {type(ohlcv)}. Data: {str(ohlcv)[:200]}..."
            )
            return None
        # Check first row length only after ensuring ohlcv is not empty and is a list of lists
        if not ohlcv or len(ohlcv[0]) != 6:
            logger.error(
                f"❌ Unexpected OHLCV format received for {symbol}. Expected 6 columns (ts,o,h,l,c,v), got {len(ohlcv[0]) if ohlcv and ohlcv[0] else 'N/A'}. Data: {ohlcv[0] if ohlcv and ohlcv[0] else 'N/A'}"
            )
            return None

        # Basic check for timestamp ordering (should be increasing)
        if (
            len(ohlcv) > 1
            and ohlcv[-1][OHLCV_INDEX["timestamp"]] < ohlcv[0][OHLCV_INDEX["timestamp"]]
        ):
            logger.warning(
                "⚠️ OHLCV timestamps appear to be in descending order. Reversing array."
            )
            ohlcv.reverse()  # Ensure data is oldest to newest for calculations

        # Check if enough data was actually returned (sometimes less than limit is provided)
        # Use a more dynamic threshold based on need, e.g., max lookback required by indicators
        min_required_candles = max(
            config.long_st_period + 2, # Supertrend needs period + 2 for stateless estimation
            DEFAULT_VOLUME_LONG_PERIOD # Volume ratio needs long period
        )
        if len(ohlcv) < min_required_candles:
            logger.warning(
                f"⚠️ Insufficient OHLCV data received ({len(ohlcv)}) for calculations (need at least {min_required_candles}) for {symbol}. Skipping analysis this cycle."
            )
            return None  # Return None if fundamentally insufficient for indicators

        logger.debug(
            f"📈 Successfully fetched {len(ohlcv)} OHLCV candles for {symbol}."
        )
        # Convert numeric fields to floats for consistency, handle potential None values
        validated_ohlcv = []
        for i, row in enumerate(ohlcv):
            try:
                # Check if row has expected length before accessing indices
                if len(row) != 6:
                    logger.warning(
                        f"Skipping OHLCV row {i} due to incorrect length ({len(row)}): {row}"
                    )
                    continue

                ts = int(row[OHLCV_INDEX["timestamp"]]) # Timestamp should be int
                o = safe_float(row[OHLCV_INDEX["open"]])
                h = safe_float(row[OHLCV_INDEX["high"]])
                l = safe_float(row[OHLCV_INDEX["low"]])
                c = safe_float(row[OHLCV_INDEX["close"]])
                v = safe_float(row[OHLCV_INDEX["volume"]])

                # Check for zero prices which might indicate bad data
                if (
                    h < FLOAT_TOLERANCE
                    or l < FLOAT_TOLERANCE
                    or c < FLOAT_TOLERANCE
                    or o < FLOAT_TOLERANCE
                ):
                    logger.warning(
                        f"Row {i} has zero/negative price(s): [T:{ts}, O:{o:.4f}, H:{h:.4f}, L:{l:.4f}, C:{c:.4f}, V:{v:.2f}]. Using row cautiously or consider skipping."
                    )
                    # Option: Skip bad rows entirely? For now, keep but warn.
                    # continue
                # Ensure H >= L and prices are reasonable (e.g., H >= O, H >= C, L <= O, L <= C)
                # Use tolerance for comparisons
                if h < l - FLOAT_TOLERANCE or \
                   h < o - FLOAT_TOLERANCE or h < c - FLOAT_TOLERANCE or \
                   l > o + FLOAT_TOLERANCE or l > c + FLOAT_TOLERANCE:
                    logger.warning(
                        f"Row {i} has inconsistent OHLC values: [T:{ts}, O:{o:.4f}, H:{h:.4f}, L:{l:.4f}, C:{c:.4f}, V:{v:.2f}]. Using row cautiously."
                    )
                    # Attempt basic correction if possible? Safer to just warn.
                    # h = max(o, h, l, c)
                    # l = min(o, h, l, c)

                validated_row = [ts, o, h, l, c, v]
                validated_ohlcv.append(validated_row)
            except (ValueError, TypeError, IndexError) as e:
                logger.error(
                    f"❌ Error processing OHLCV row {i}: {row}. Error: {e}. Skipping row."
                )
                continue  # Skip rows with conversion errors

        if not validated_ohlcv:
            logger.error(
                "❌ No valid OHLCV rows remaining after validation/conversion."
            )
            return None
        if len(validated_ohlcv) < min_required_candles:
            logger.warning(
                f"⚠️ Insufficient VALID OHLCV data after cleaning ({len(validated_ohlcv)} rows) for calculations (need {min_required_candles}). Skipping analysis."
            )
            return None

        return validated_ohlcv

    except (
        ccxt.NetworkError,
        NewConnectionError,
        MaxRetryError,
        Urllib3TimeoutError,
        ccxt.RequestTimeout, # Added
    ) as e:
        logger.warning(f"🕸️ Network error fetching OHLCV for {symbol}: {type(e).__name__} - {e}")
        return None
    except ccxt.ExchangeError as e:
        logger.error(f"🏛️ Exchange error fetching OHLCV for {symbol}: {e}")
        # Check for specific errors if needed (e.g., invalid symbol/timeframe from exchange)
        if "Invalid timeframe" in str(e) or "Invalid symbol" in str(e):
             logger.error("   Please verify TIMEFRAME and SYMBOL configuration.")
        return None
    except Exception as e:
        logger.exception(f"💥 Unexpected error fetching OHLCV for {symbol}: {e}")
        return None


def calculate_atr(ohlcv: list[list[int | float]], period: int) -> float | None:
    """Calculates the Average True Range (ATR) for the latest full period.

    Requires `period + 1` candles to calculate the first TR value correctly within the lookback window.
    Uses the last `period` True Range values for the simple moving average (SMA) calculation of ATR.

    Args:
        ohlcv: List of validated OHLCV lists [[ts, o, h, l, c, v], ...] (sorted oldest to newest).
        period: The lookback period for ATR calculation (must be > 0).

    Returns:
        The calculated ATR value for the *last* candle's period,
        or None if calculation is not possible (e.g., insufficient data, invalid period, zero ATR).
    """
    if period <= 0:
        logger.error(f"❌ Invalid ATR period: {period}. Must be positive.")
        return None
    required_length = (
        period + 1
    )  # Need previous close for the first TR calculation in the window
    if not ohlcv or len(ohlcv) < required_length:
        logger.debug(
            f"Not enough data to calculate ATR({period}). Need {required_length}, have {len(ohlcv) if ohlcv else 0}."
        )
        return None

    trs = []
    try:
        # Calculate TR for the last 'period' candles using 'period+1' total candles
        # Loop starts from index `len(ohlcv) - period` up to the end (index len(ohlcv) - 1)
        start_index = len(ohlcv) - period
        for i in range(start_index, len(ohlcv)):
            # Validate data points exist and are numeric before using
            # Use safe_float which handles None and conversion errors, returning default -1.0
            high = safe_float(ohlcv[i][OHLCV_INDEX["high"]], -1.0)
            low = safe_float(ohlcv[i][OHLCV_INDEX["low"]], -1.0)
            prev_close = safe_float(ohlcv[i - 1][OHLCV_INDEX["close"]], -1.0)

            # Check if safe_float returned default error value (-1.0) or if prices are non-positive
            if (
                high < FLOAT_TOLERANCE
                or low < FLOAT_TOLERANCE
                or prev_close < FLOAT_TOLERANCE
            ):
                logger.warning(
                    f"Invalid price data (<=0 or conversion failed) in ATR calculation at index {i}: H={high:.4f}, L={low:.4f}, PrevC={prev_close:.4f}. Skipping TR for this candle."
                )
                continue

            tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
            trs.append(tr)

        if not trs:
            logger.warning(
                f"⚠️ ATR({period}) calculation resulted in empty True Range list (possibly due to data issues in all {period} candles)."
            )
            return None
        if len(trs) != period:
            # This might happen if some candles had invalid data and were skipped
            logger.warning(
                f"⚠️ ATR({period}) calculation yielded {len(trs)} TR values, expected {period}. Result might be inaccurate (based on fewer values)."
            )
            if not trs: # Double check if list became empty after partial calculation
                return None

        # Calculate simple moving average of TRs for the ATR
        atr = sum(trs) / len(trs)  # Use len(trs) in case it's less than period

        # Check for near-zero ATR, which can cause division by zero or illogical stops
        if atr < FLOAT_TOLERANCE:
            logger.warning(
                f"⚠️ Calculated ATR({period}) is near zero ({atr:.8f}). Returning None to avoid issues in risk/SL/TP calculation."
            )
            return None

        logger.debug(
            f"Calculated ATR({period}) = {Style.BRIGHT}{atr:.5f}{Style.RESET_ALL}"
        )
        return atr

    except (IndexError, ValueError, TypeError) as e:
        logger.error(
            f"❌ Error calculating ATR({period}): {e}. Check OHLCV data integrity. Data sample: {ohlcv[-required_length:]}"
        )
        return None
    except Exception as e:
        logger.exception(f"💥 Unexpected error in calculate_atr: {e}")
        return None


def calculate_supertrend(
    ohlcv: list[list[int | float]], period: int, multiplier: float
) -> tuple[float | None, bool | None]:
    """Calculates the Supertrend indicator value and direction for the *latest* candle
    using a **STATELESS estimation method**.

    WARNING: This stateless calculation approximates the previous Supertrend state based on
    limited historical data (specifically, the last `period + 2` candles). This can lead to
    significant differences compared to stateful implementations (like TradingView or MT4/5)
    which maintain the trend band across candles until a break occurs.
    Use the results with extreme caution, especially on shorter timeframes or during volatile periods.
    It is STRONGLY recommended to compare results with a known stateful implementation or library
    (e.g., pandas-ta if feasible) before relying on these signals for trading.

    Requires `period + 2` candles for the internal estimation logic.

    Args:
        ohlcv: List of validated OHLCV lists [[ts, o, h, l, c, v], ...] (sorted oldest to newest).
        period: The lookback period for ATR calculation within Supertrend (must be > 0).
        multiplier: The ATR multiplier for band calculation (must be > 0).

    Returns:
        A tuple (current_supertrend_value, is_uptrend):
        - current_supertrend_value (float): The estimated value of the Supertrend line for the latest candle.
        - is_uptrend (bool): True if the estimated trend is currently up, False if down.
        Returns (None, None) if calculation fails (e.g., insufficient data, invalid params).
    """
    if period <= 0 or multiplier <= FLOAT_TOLERANCE:
        logger.error(
            f"❌ Invalid Supertrend parameters: period={period}, multiplier={multiplier}. Period must be > 0, multiplier > {FLOAT_TOLERANCE}."
        )
        return None, None
    # Need period+1 for current ATR, period+2 for previous ATR estimation and prev-prev close
    required_length = period + 2
    if not ohlcv or len(ohlcv) < required_length:
        logger.debug(
            f"Not enough data for stateless Supertrend({period}, {multiplier}). Need {required_length}, have {len(ohlcv) if ohlcv else 0}."
        )
        return None, None

    logger.debug(
        f"Calculating Supertrend({period}, {multiplier}) using stateless estimation..."
    )
    # Explicit warning about the stateless nature - make it more prominent
    logger.warning(
        f"{Fore.RED}{Style.BRIGHT}   ####################################################################{Style.RESET_ALL}"
    )
    logger.warning(
        f"{Fore.RED}{Style.BRIGHT}   # WARNING: Using STATELESS Supertrend({period},{multiplier}) estimation.      #{Style.RESET_ALL}"
    )
    logger.warning(
        f"{Fore.RED}{Style.BRIGHT}   # Signals may differ significantly from stateful versions (e.g., TV). #{Style.RESET_ALL}"
    )
    logger.warning(
        f"{Fore.RED}{Style.BRIGHT}   # Use with extreme caution and verify behavior before live trading!   #{Style.RESET_ALL}"
    )
    logger.warning(
        f"{Fore.RED}{Style.BRIGHT}   # Consider pandas-ta (pip install pandas-ta) for stateful calc.    #{Style.RESET_ALL}"
    )
    logger.warning(
        f"{Fore.RED}{Style.BRIGHT}   ####################################################################{Style.RESET_ALL}"
    )


    try:
        # --- Data Extraction for relevant candles ---
        # Ensure data is valid before proceeding using safe_float
        # Default to -1.0 to easily detect failure
        # Current candle (-1)
        high = safe_float(ohlcv[-1][OHLCV_INDEX["high"]], -1.0)
        low = safe_float(ohlcv[-1][OHLCV_INDEX["low"]], -1.0)
        close = safe_float(ohlcv[-1][OHLCV_INDEX["close"]], -1.0)
        # Previous candle (-2)
        prev_high = safe_float(ohlcv[-2][OHLCV_INDEX["high"]], -1.0)
        prev_low = safe_float(ohlcv[-2][OHLCV_INDEX["low"]], -1.0)
        prev_close = safe_float(ohlcv[-2][OHLCV_INDEX["close"]], -1.0)
        # Previous-previous candle (-3) - Only need close
        prev_prev_close = safe_float(ohlcv[-3][OHLCV_INDEX["close"]], -1.0)

        # Check for invalid prices (<= 0 or conversion failed)
        if any(
            p < FLOAT_TOLERANCE
            for p in [
                high, low, close, prev_high, prev_low, prev_close, prev_prev_close
            ]
        ):
            logger.error(
                "❌ Zero, negative, or invalid price detected in Supertrend input data near latest candles. Cannot calculate."
            )
            return None, None

        # --- Calculate ATR for the *previous* candle ---
        # Use data up to the second to last candle (index -2 included)
        prev_atr = calculate_atr(ohlcv[:-1], period)
        if prev_atr is None or prev_atr < FLOAT_TOLERANCE:
            logger.warning(
                f"⚠️ Previous ATR({period}) calculation failed or returned near-zero ({prev_atr}), cannot calculate Supertrend."
            )
            return None, None

        # --- Calculate Basic Bands for the *previous* candle ---
        prev_hl2 = (prev_high + prev_low) / 2
        prev_basic_upper = prev_hl2 + multiplier * prev_atr
        prev_basic_lower = prev_hl2 - multiplier * prev_atr

        # --- Estimate Final Bands for the *previous* candle (STATELESS APPROXIMATION) ---
        # This remains the core weakness. We estimate the previous Supertrend state.
        # Refined approach: Estimate previous trend based on prev_close vs prev_basic_bands,
        # and use that estimated trend to select the *previous* final band estimate.

        # Step 1: Estimate previous trend direction
        # Default to previous trend being UP if prev_close was above prev_basic_lower
        # This ignores the stickiness/clamping completely for the previous state estimation.
        est_prev_up_trend = True # Assume up initially
        if prev_close < prev_basic_lower - FLOAT_TOLERANCE:
             est_prev_up_trend = False # If prev close was below prev lower band, estimate prev trend was down
        # If between bands, the simple stateless model often assumes the trend continued from prev-prev.
        # A slightly better guess might use prev_prev_close vs prev_basic_bands.
        elif prev_close < prev_basic_upper - FLOAT_TOLERANCE: # If close is between basic bands
             # Estimate trend based on prev_prev_close relative to prev_basic_bands
             if prev_prev_close < prev_basic_upper - FLOAT_TOLERANCE: # If prev_prev suggested DOWN
                 est_prev_up_trend = False
             # else: keep est_prev_up_trend = True (default assumption if prev_prev was above lower)

        # Step 2: Estimate previous Supertrend value based on estimated previous trend
        # This is a simplification: In reality, the previous ST value would be clamped.
        # Statelessly, we just use the basic band corresponding to the estimated trend.
        est_prev_supertrend_value = prev_basic_lower if est_prev_up_trend else prev_basic_upper


        # --- Calculate ATR and Basic Bands for the *current* candle ---
        # Use all available data up to the last candle
        current_atr = calculate_atr(ohlcv, period)
        if current_atr is None or current_atr < FLOAT_TOLERANCE:
            logger.warning(
                f"⚠️ Current ATR({period}) calculation failed or returned near-zero ({current_atr}), cannot complete Supertrend."
            )
            return None, None

        current_hl2 = (high + low) / 2
        basic_upper = current_hl2 + multiplier * current_atr
        basic_lower = current_hl2 - multiplier * current_atr

        # --- Calculate Final Bands and Trend for the *current* candle using *estimated* previous state ---
        current_final_lower = basic_lower
        current_final_upper = basic_upper
        current_supertrend_value: float | None = None
        current_up_trend: bool | None = None

        # Apply the clamping logic based on the *estimated* previous trend and *estimated* previous final band value
        if est_prev_up_trend:  # If we estimate previous trend was UP
            current_final_lower = max(
                basic_lower, est_prev_supertrend_value
            )  # Clamp current lower band using estimated previous ST value
            # Determine current trend: Continues UP unless close breaks below current_final_lower
            if close < current_final_lower - FLOAT_TOLERANCE:
                current_up_trend = False
                current_supertrend_value = current_final_upper  # On flip down, ST value becomes the *current* final upper band
            else:
                current_up_trend = True
                current_supertrend_value = current_final_lower  # While up, ST value is the *current* final lower band
        else:  # If we estimate previous trend was DOWN
            current_final_upper = min(
                basic_upper, est_prev_supertrend_value
            )  # Clamp current upper band using estimated previous ST value
            # Determine current trend: Continues DOWN unless close breaks above current_final_upper
            if close > current_final_upper + FLOAT_TOLERANCE:
                current_up_trend = True
                current_supertrend_value = current_final_lower  # On flip up, ST value becomes the *current* final lower band
            else:
                current_up_trend = False
                current_supertrend_value = current_final_upper  # While down, ST value is the *current* final upper band

        # Final sanity check on calculated value
        if current_supertrend_value is None or current_up_trend is None:
            logger.error(
                "❌ Supertrend calculation failed to determine final value or trend after estimation."
            )
            return None, None
        if current_supertrend_value < FLOAT_TOLERANCE:
            logger.warning(
                f"⚠️ Calculated Supertrend value ({current_supertrend_value:.5f}) is near zero or negative. Using cautiously."
            )
            # Allow near-zero value but log warning. Ensure it doesn't break price comparisons later.

        trend_color = Fore.GREEN if current_up_trend else Fore.RED
        trend_str = "UP" if current_up_trend else "DOWN"
        logger.debug(
            f"Supertrend({period}, {multiplier}) Est: Value={Style.BRIGHT}{current_supertrend_value:.5f}{Style.NORMAL}, Trend={trend_color}{trend_str}{Style.RESET_ALL}"
        )

        return current_supertrend_value, current_up_trend

    except (IndexError, ValueError, TypeError) as e:
        logger.error(
            f"❌ Error calculating stateless Supertrend({period}, {multiplier}): {e}. Check OHLCV data integrity. Data sample: {ohlcv[-required_length:]}"
        )
        return None, None
    except Exception as e:
        logger.exception(f"💥 Unexpected error in calculate_supertrend: {e}")
        return None, None


def fetch_volume_ratio(
    ohlcv_data: list[list[int | float]],
    short_period: int = DEFAULT_VOLUME_SHORT_PERIOD,
    long_period: int = DEFAULT_VOLUME_LONG_PERIOD,
) -> float | None:
    """Calculates the ratio of recent average volume to longer-term average volume.

    Args:
        ohlcv_data: List of validated OHLCV lists (sorted oldest to newest).
        short_period: Lookback period for recent average volume (must be > 0).
        long_period: Lookback period for longer-term average volume (must be > short_period).

    Returns:
        The volume ratio (short_avg / long_avg), or None if calculation is not possible.
    """
    if not (long_period > short_period > 0):
        logger.warning(
            f"⚠️ Invalid periods for volume ratio: short={short_period}, long={long_period}. Requirements: long > short > 0."
        )
        return None
    if not ohlcv_data or len(ohlcv_data) < long_period:
        logger.debug(
            f"Not enough data for volume ratio ({short_period}/{long_period}). Need {long_period}, have {len(ohlcv_data) if ohlcv_data else 0}."
        )
        return None

    try:
        # Extract volumes from the end of the list, ensure they are valid numbers (>= 0)
        volumes = []
        # Iterate backwards from the latest candle (-1) up to -(long_period)
        for i in range(1, long_period + 1):
            if len(ohlcv_data) >= i and len(ohlcv_data[-i]) == 6:
                # Use index -i to get recent candles
                vol = safe_float(ohlcv_data[-i][OHLCV_INDEX["volume"]], -1.0)
                if vol >= 0.0:  # Only use non-negative volumes
                    volumes.append(vol)
                else:
                    logger.warning(
                        f"Invalid volume data (negative or conversion failed) found at index {-i}. Skipping."
                    )
            else:
                logger.warning(
                    f"Incomplete OHLCV data near end for volume ratio. Index {-i} invalid."
                )
                # If data is missing within the required period, we cannot reliably calculate
                return None

        # Reverse volumes list to be oldest to newest within the period window
        volumes.reverse()

        if len(volumes) < long_period:
            logger.warning(
                f"Could only extract {len(volumes)} valid volumes, less than required {long_period}. Ratio may be inaccurate."
            )
            if len(volumes) < short_period:  # Need at least short_period volumes
                logger.error(
                    f"Insufficient valid volumes ({len(volumes)}) even for short period ({short_period}). Cannot calculate ratio."
                )
                return None

        # Slice for short/long periods from the validated list
        # `volumes` now holds up to `long_period` recent valid volumes, oldest to newest
        short_vols = volumes[-short_period:]
        long_vols = volumes  # Use all extracted valid volumes up to long_period

        # Calculate averages, ensuring periods used match available data
        actual_short_period = len(short_vols)
        actual_long_period = len(long_vols)
        if actual_short_period == 0 or actual_long_period == 0:
            logger.error("Cannot calculate volume average with zero valid volumes.")
            return None

        avg_short_vol = sum(short_vols) / actual_short_period
        avg_long_vol = sum(long_vols) / actual_long_period

        # Check for zero or near-zero long-term volume to avoid division by zero
        if avg_long_vol < FLOAT_TOLERANCE:
            logger.warning(
                f"⚠️ Long period ({actual_long_period}) average volume is near zero ({avg_long_vol:.4f}). Cannot calculate meaningful volume ratio."
            )
            # Return None to indicate invalid ratio, rather than infinity or zero
            return None

        ratio = avg_short_vol / avg_long_vol
        ratio_color = (
            Fore.GREEN if ratio > config.volume_spike_threshold else Fore.WHITE
        )
        logger.debug(
            f"Volume Ratio ({actual_short_period}/{actual_long_period}): {ratio_color}{Style.BRIGHT}{ratio:.3f}{Style.RESET_ALL} (AvgShort={avg_short_vol:.2f}, AvgLong={avg_long_vol:.2f})"
        )
        return ratio

    except (IndexError, TypeError, ValueError, ZeroDivisionError) as e:
        logger.error(
            f"❌ Error calculating volume ratio: {e}. Check OHLCV data format. Data sample: {ohlcv_data[-long_period:]}"
        )
        return None
    except Exception as e:
        logger.exception(f"💥 Unexpected error calculating volume ratio: {e}")
        return None


def fetch_order_book_pressure(
    exch: ccxt.Exchange | None, symbol: str, depth: int = DEFAULT_ORDER_BOOK_DEPTH
) -> float | None:
    """Calculates the order book pressure based on the cumulative volume of top N bids and asks.

    Pressure = Total Bid Volume / (Total Bid Volume + Total Ask Volume)
    A value > 0.5 indicates more volume on the bid side (bullish pressure).
    A value < 0.5 indicates more volume on the ask side (bearish pressure).
    Returns 0.5 (neutral) if the order book is empty or total volume is zero.

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run).
        symbol: The market symbol (e.g., "BTCUSDT").
        depth: The number of order book levels (bids and asks) to consider (must be > 0).

    Returns:
        The bid pressure ratio (0.0 to 1.0), or None on API/parsing failure. Returns mock value if exch is None (dry run).
    """
    if depth <= 0:
        logger.error(f"❌ Invalid order book depth: {depth}. Must be positive.")
        return None
    if not exch:
        if config.dry_run:
            # Simulate some fluctuation around 0.5
            mock_pressure = 0.5 + (time.time() % 0.4 - 0.2) # Fluctuates between 0.3 and 0.7
            mock_pressure = max(0.0, min(1.0, mock_pressure)) # Clamp between 0 and 1
            logger.debug(
                f"DRY RUN: Simulating fetch_order_book_pressure for {symbol} (depth={depth}). Returning mock pressure: {mock_pressure:.3f}"
            )
            return mock_pressure
        else:
            logger.error(
                "❌ Cannot fetch order book: Exchange object is not available and not in dry run mode."
            )
            return None

    logger.debug(
        f"⚖️ Fetching order book for {symbol} (depth={depth}) to calculate pressure..."
    )
    order_book = None  # Initialize to None for error handling scope
    bids, asks = [], []  # Initialize lists
    try:
        # Some exchanges might return more levels than requested, CCXT usually handles limit param correctly.
        # Specify category for V5
        params = {'category': 'linear'}
        try:
            if exch.market(symbol).get('inverse'):
                params['category'] = 'inverse'
        except Exception: pass

        order_book = exch.fetch_order_book(symbol, limit=depth, params=params)

        # Validate structure
        if (
            not isinstance(order_book, dict)
            or "bids" not in order_book
            or "asks" not in order_book
        ):
            logger.error(
                f"❌ Unexpected order book structure received for {symbol}. Keys: {list(order_book.keys()) if isinstance(order_book, dict) else type(order_book)}"
            )
            logger.debug(f"Raw order book data: {str(order_book)[:500]}...")
            return None

        bids = order_book.get("bids", [])
        asks = order_book.get("asks", [])

        if not isinstance(bids, list) or not isinstance(asks, list):
            logger.error(
                f"❌ Unexpected order book format for {symbol}. Bids/Asks are not lists. Bids: {type(bids)}, Asks: {type(asks)}"
            )
            return None

        # Sum the volume (amount) from the top 'depth' levels
        # Format is usually [price, amount]
        # Use safe_float for conversion and handle potential invalid levels
        bid_vol = 0.0
        ask_vol = 0.0
        bid_levels_processed = 0
        ask_levels_processed = 0

        for level in bids[:depth]: # Ensure we only process up to 'depth' levels
            if isinstance(level, list) and len(level) >= 2:
                vol = safe_float(level[1], -1.0) # Use -1 default to check for conversion failure
                if vol >= 0.0: # Only sum non-negative volumes
                    bid_vol += vol
                    bid_levels_processed += 1
                else:
                    logger.warning(f"Invalid bid volume format/value in level: {level}")
            else:
                logger.warning(f"Invalid bid level format: {level}")
        for level in asks[:depth]:
            if isinstance(level, list) and len(level) >= 2:
                 vol = safe_float(level[1], -1.0)
                 if vol >= 0.0:
                    ask_vol += vol
                    ask_levels_processed += 1
                 else:
                     logger.warning(f"Invalid ask volume format/value in level: {level}")
            else:
                logger.warning(f"Invalid ask level format: {level}")

        total_vol = bid_vol + ask_vol

        # Handle case of empty or zero-volume order book within the specified depth
        if total_vol < FLOAT_TOLERANCE:
            # Check if any levels were processed at all
            if bid_levels_processed == 0 and ask_levels_processed == 0:
                logger.warning(
                    f"⚠️ Order book for {symbol} (depth {depth}) appears empty or has invalid volume data in all levels. Returning neutral pressure (0.5)."
                )
            else:
                logger.warning(
                    f"⚠️ Total volume in top {depth} levels (processed {bid_levels_processed} bids, {ask_levels_processed} asks) of order book for {symbol} is near zero ({total_vol:.4f}). BidVol={bid_vol:.4f}, AskVol={ask_vol:.4f}. Returning neutral pressure (0.5)."
                )
            # Return neutral pressure (avoids division by zero and indicates no clear pressure)
            return 0.5

        pressure = bid_vol / total_vol

        # Determine color based on threshold for long/short pressure signals
        is_long_pressure = pressure > config.ob_pressure_threshold
        # Short pressure means low bid pressure (or high ask pressure relative to total)
        is_short_pressure = pressure < (1.0 - config.ob_pressure_threshold)
        pressure_color = (
            Fore.GREEN
            if is_long_pressure
            else (Fore.RED if is_short_pressure else Fore.WHITE)
        )

        logger.debug(
            f"Order Book Pressure ({symbol}, depth={depth}): {pressure_color}{Style.BRIGHT}{pressure:.3f}{Style.RESET_ALL} (BidVol={bid_vol:.4f}, AskVol={ask_vol:.4f})"
        )
        return pressure

    except (
        ccxt.NetworkError,
        NewConnectionError,
        MaxRetryError,
        Urllib3TimeoutError,
        ccxt.RequestTimeout, # Added
    ) as e:
        logger.warning(f"🕸️ Network error fetching order book for {symbol}: {type(e).__name__} - {e}")
        return None
    except ccxt.ExchangeError as e:
        logger.error(f"🏛️ Exchange error fetching order book for {symbol}: {e}")
        return None
    except (IndexError, TypeError, ValueError, ZeroDivisionError) as e:
        # Log error, but avoid logging potentially huge order book data unless debugging
        logger.error(f"❌ Error parsing order book data for {symbol}: {e}.")
        logger.debug(f"Order book bids sample: {bids[:2]}, asks sample: {asks[:2]}")
        return None
    except Exception as e:
        logger.exception(
            f"💥 Unexpected error fetching order book pressure for {symbol}: {e}"
        )
        return None


def get_position(
    exch: ccxt.Exchange | None, symbol: str
) -> tuple[PositionSide, float, float]:
    """Fetches the current position details for a specific symbol using Bybit V5 API structure via CCXT.
    Handles potential errors and returns a clear state. Assumes One-Way mode unless warning logged.

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run).
        symbol: The market symbol (e.g., "BTCUSDT").

    Returns:
        A tuple containing:
        - PositionSide (LONG, SHORT, or NONE)
        - Position amount (absolute value, in base currency, e.g., BTC amount for BTCUSDT)
        - Average entry price (0.0 if no position)
        Returns (PositionSide.NONE, 0.0, 0.0) if exch is None (dry run simulation assumes no position
        unless state is managed externally) or on API failure/parsing error.
    """
    if not exch:
        if config.dry_run:
            # In dry run, we rely on the externally managed state (`dry_run_position`).
            # This function *could* return that state, but it's simpler to keep state management
            # within the main trade_logic function for this implementation.
            # So, a direct call here in dry run assumes no position initially.
            logger.debug(
                "DRY RUN: Simulating get_position. Returning state from trade_logic (initially NONE)."
            )
            # Returning NONE here, actual state used comes from `dry_run_position` global in `trade_logic`
            return PositionSide.NONE, 0.0, 0.0
        else:
            logger.error(
                "❌ Cannot fetch position: Exchange object is not available and not in dry run mode."
            )
            return PositionSide.NONE, 0.0, 0.0

    logger.debug(f"🔍 Fetching position details for {symbol}...")
    positions = None  # Initialize for error handling scope
    try:
        # Determine category based on market info for Bybit V5
        market = exch.market(symbol)
        category = "linear"  # Default assumption
        if market.get("inverse"):
            category = "inverse"
        logger.debug(f"Using category '{category}' for fetching position {symbol}.")

        params = {
            "category": category,
            "symbol": symbol,
            # Add settleCoin if needed, e.g., for USDC contracts
            # 'settleCoin': 'USDC' if category == 'linear' and symbol.endswith('PERP') else None
        }
        # Request only the specific symbol to reduce response size and potential ambiguity
        # Note: fetch_positions might still return multiple entries if in hedge mode, even with symbol filter.
        # Using symbols=[symbol] might be redundant if params={'symbol': symbol} works reliably.
        positions = exch.fetch_positions(symbols=[symbol], params=params)
        logger.debug(
            f"Raw positions response for {symbol} ({category}): {str(positions)[:500]}..."
        )  # Debugging, limit length

        target_position_info = None
        # fetch_positions should return a list. Iterate through it.
        if positions and isinstance(positions, list):
            # Filter for the position with a non-negligible size for the target symbol
            # Bybit V5 uses 'size' (string) in info, CCXT maps to 'contracts' (float). Check both.
            # Check 'side' ('Buy'/'Sell') and 'size' from 'info' for V5 consistency.
            # CCXT standard 'side' ('long'/'short') and 'contracts' might also work.
            active_positions = []
            for p in positions:
                # Basic validation of position entry
                if not isinstance(p, dict) or not p.get('info'):
                    logger.debug(f"Skipping invalid position entry in list: {p}")
                    continue

                pos_symbol = p.get("symbol", "").upper() # CCXT standard symbol
                info = p.get("info", {})
                info_symbol = info.get("symbol", "").upper() # V5 info symbol

                # Check if either symbol matches the target symbol
                if pos_symbol != symbol.upper() and info_symbol != symbol.upper():
                    continue # Skip if symbol doesn't match

                # Get size: Prioritize V5 'size', fallback to CCXT 'contracts'
                size_str = info.get("size", "0")
                pos_size_info = safe_float(size_str, 0.0)
                contracts_size = safe_float(p.get("contracts"), 0.0)

                # Use the size reported by 'info' if available and non-zero, otherwise use 'contracts'
                # This assumes 'size' in info is the most reliable field for V5
                effective_size = pos_size_info if abs(pos_size_info) > FLOAT_TOLERANCE else contracts_size

                if abs(effective_size) > FLOAT_TOLERANCE:
                    active_positions.append(p)

            if len(active_positions) > 1:
                # This strongly suggests Hedge Mode is enabled on Bybit account
                logger.warning(
                    f"⚠️ Found multiple active position entries ({len(active_positions)}) for {symbol} in fetch_positions response. This likely indicates Hedge Mode is enabled. This bot assumes One-Way mode and will use the FIRST entry found. Position size/logic might be incorrect in Hedge Mode!"
                )
                # Potentially add config to stop bot if Hedge Mode detected?
                # if config.stop_on_hedge_mode: sys.exit("Stopping: Hedge Mode detected, bot requires One-Way mode.")
                target_position_info = active_positions[0]  # Take the first one found
            elif len(active_positions) == 1:
                target_position_info = active_positions[0]
                logger.debug(
                    f"Found unique active position entry matching symbol {symbol}."
                )
            else:
                logger.debug(
                    f"No active position found for {symbol} in the response list (size is zero or negligible)."
                )
                # Check if there was *any* entry for the symbol, even if size was zero
                zero_size_pos = [
                    p for p in positions if isinstance(p, dict) and (p.get("symbol", "").upper() == symbol.upper() or p.get("info", {}).get("symbol", "").upper() == symbol.upper())
                ]
                if zero_size_pos:
                    logger.debug("   (An entry exists but size is zero or negligible)")

        if target_position_info:
            # --- Parse Position Details (Prioritize V5 'info' structure) ---
            info = target_position_info.get("info", {}) # Already checked this exists

            # Size: Bybit V5 uses 'size' (string, base currency amount). CCXT maps to 'contracts'.
            # Use the effective_size calculation logic from filtering above.
            size_str = info.get("size", "0")
            pos_size_info = safe_float(size_str, 0.0)
            contracts_size = safe_float(target_position_info.get("contracts"), 0.0)
            position_amount = pos_size_info if abs(pos_size_info) > FLOAT_TOLERANCE else contracts_size

            # Side: Bybit V5 uses 'side' ('Buy'/'Sell' for Long/Short). CCXT maps to 'side' ('long'/'short').
            side_v5 = info.get("side", "").lower()  # 'buy' or 'sell' or 'None' maybe?
            side_ccxt = target_position_info.get("side", "").lower()  # 'long' or 'short'

            position_side = PositionSide.NONE
            if abs(position_amount) > FLOAT_TOLERANCE:
                # Prioritize V5 side interpretation if available and clear
                if side_v5 == "buy":
                    position_side = PositionSide.LONG
                elif side_v5 == "sell":
                    position_side = PositionSide.SHORT
                # Fallback to CCXT side if V5 side is unclear or missing
                elif side_ccxt == "long":
                    position_side = PositionSide.LONG
                elif side_ccxt == "short":
                    position_side = PositionSide.SHORT
                else:
                    logger.warning(
                        f"Position found for {symbol} with size={position_amount:.8f} but unclear side (V5: '{side_v5}', CCXT: '{side_ccxt}'). Assuming NONE for safety."
                    )
                    # Reset amount if side is truly unknown
                    position_amount = 0.0

            # Entry Price: Bybit V5 uses 'avgPrice' (string). CCXT maps to 'entryPrice'.
            entry_price_str = info.get("avgPrice", "0")
            entry_price_info = safe_float(entry_price_str, 0.0)
            entry_price_ccxt = safe_float(target_position_info.get("entryPrice"), 0.0)

            # Use V5 price if available and positive, otherwise fallback to CCXT price
            entry_price = entry_price_info if entry_price_info > FLOAT_TOLERANCE else entry_price_ccxt


            # Perform final check on parsed values
            if (
                position_side != PositionSide.NONE
                and abs(position_amount) > FLOAT_TOLERANCE
                and entry_price > FLOAT_TOLERANCE
            ):
                logger.debug(
                    f"Parsed {position_side.value} position: Size={position_amount:.8f}, Entry={entry_price:.5f}"
                )
                return (
                    position_side,
                    abs(position_amount), # Return absolute amount
                    entry_price,
                )
            else:
                # Position entry exists but parsed values indicate no active position
                # This can happen if size becomes zero after parsing, or entry price is invalid
                logger.debug(
                    f"Position data found for {symbol}, but parsed state is effectively flat (Side: {position_side.value}, Amount: {position_amount:.8f}, Entry: {entry_price:.5f}). Assuming no position."
                )
                return PositionSide.NONE, 0.0, 0.0
        else:
            # fetch_positions returned empty list or no active position matching symbol
            logger.debug(
                f"No active position confirmed for {symbol} after parsing fetch_positions response."
            )
            return PositionSide.NONE, 0.0, 0.0

    except (
        ccxt.NetworkError,
        NewConnectionError,
        MaxRetryError,
        Urllib3TimeoutError,
        ccxt.RequestTimeout, # Added
    ) as e:
        logger.warning(
            f"🕸️ Network error fetching position for {symbol}: {type(e).__name__} - {e}. Assuming no position for safety."
        )
        return PositionSide.NONE, 0.0, 0.0
    except ccxt.ExchangeError as e:
        # Bybit might return specific errors, check common ones indicating no position
        err_str = str(e).lower()
        # Bybit V5 error codes for position not found:
        # 110021 ("position status is not normal" - often means no position)
        # Check for messages too.
        no_pos_codes = [110021]
        no_pos_keywords = ["position idx not exist", "position not found", "no position found"]

        if any(str(code) in str(e) for code in no_pos_codes) or \
           any(keyword in err_str for keyword in no_pos_keywords):
            logger.info(
                f"ℹ️ No position exists for {symbol} according to exchange response ({e})."
            )
            return PositionSide.NONE, 0.0, 0.0
        else: # Log other exchange errors
            logger.error(f"🏛️ Exchange error fetching position for {symbol}: {e}")
            return PositionSide.NONE, 0.0, 0.0  # Assume no position on other errors
    except (KeyError, TypeError, ValueError, IndexError) as e:
        logger.error(
            f"❌ Error parsing position response structure for {symbol}: {e}. Assuming no position."
        )
        logger.debug(
            f"Position response causing parsing error: {str(positions)[:500]}..."
        )  # Log raw data if debugging
        return PositionSide.NONE, 0.0, 0.0
    except Exception as e:
        logger.exception(f"💥 Unexpected error fetching position for {symbol}: {e}")
        return PositionSide.NONE, 0.0, 0.0  # Assume no position on unexpected error


def get_balance(exch: ccxt.Exchange | None, currency: str = "USDT") -> float:
    """Fetches the account equity (total balance including unrealized PnL) for a specific currency.
    Prioritizes parsing Bybit V5 Unified Trading Account (UTA) structure, falls back to standard methods.

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run).
        currency: The currency code (e.g., "USDT"). Case-insensitive.

    Returns:
        The total equity in the specified currency as a float, or 0.0 on failure / dry run simulation.
    """
    target_currency = currency.upper()  # Standardize currency code
    if not exch:
        if config.dry_run:
            # Simulate a stable equity for dry run, maybe slightly increasing over time?
            # Simple fixed value for now.
            mock_equity = 1000.0
            logger.debug(
                f"DRY RUN: Simulating get_balance for {target_currency}. Returning mock equity: {mock_equity:.4f}"
            )
            return mock_equity
        else:
            logger.error(
                "❌ Cannot fetch balance: Exchange object is not available and not in dry run mode."
            )
            return 0.0

    logger.debug(f"💰 Fetching balance/equity for currency: {target_currency}")
    balance_data = None  # Initialize for scope
    equity = 0.0
    found_equity = False

    try:
        # Bybit V5: fetch_balance might require accountType parameter for specific account types.
        # Common types: UNIFIED (UTA), CONTRACT (Classic Inverse/USDC Perps?), SPOT.
        # Let's try UNIFIED first as it's common for USDT perpetuals under UTA.
        # If that fails, try CONTRACT. If both fail, try default (no params).
        # Using None for default might not work as expected, better to try specific known types.
        # Let's prioritize UNIFIED, then CONTRACT. If specific currency isn't found, parse the generic response.
        account_types_to_try = ["UNIFIED", "CONTRACT"] # Prioritize these
        specific_equity_found = False

        for acc_type in account_types_to_try:
            try:
                params = {"accountType": acc_type}
                logger.debug(f"Attempting fetch_balance with params: {params}")
                balance_data = exch.fetch_balance(params=params)
                logger.debug(
                    f"Raw balance response ({acc_type} attempt): {str(balance_data)[:500]}..."
                )

                # --- Try Parsing Bybit V5 Structure (often nested in 'info') ---
                info = balance_data.get("info", {})
                if isinstance(info, dict):
                    result = info.get("result", {})
                    if isinstance(result, dict):
                        account_list = result.get("list", [])
                        if isinstance(account_list, list) and len(account_list) > 0:
                            account_info = account_list[0] # Assume first entry is relevant for UTA/CONTRACT
                            if isinstance(account_info, dict):
                                # 1. Check for total equity at the account level (if target is USDT, this might be it)
                                if target_currency == "USDT": # Often the main equity currency
                                    total_equity_str = account_info.get("totalEquity")
                                    if total_equity_str is not None:
                                        temp_equity = safe_float(total_equity_str, -1.0)
                                        if temp_equity >= 0.0:
                                            logger.debug(
                                                f"Found 'totalEquity' ({temp_equity:.4f} USDT) in V5 structure ({acc_type}). Using this as primary equity."
                                            )
                                            equity = temp_equity
                                            found_equity = True # Found a primary equity value
                                            # Don't break yet, check coin list for potentially more specific value

                                # 2. Check the coin list within the account for the specific target currency
                                if "coin" in account_info and isinstance(account_info["coin"], list):
                                    for coin_info in account_info["coin"]:
                                        if (
                                            isinstance(coin_info, dict)
                                            and coin_info.get("coin", "").upper()
                                            == target_currency
                                        ):
                                            # V5 structure might have 'equity', 'walletBalance', 'usdValue' etc. 'equity' seems most appropriate.
                                            equity_str = coin_info.get("equity")
                                            if equity_str is not None:
                                                temp_equity = safe_float(equity_str, -1.0)
                                                if temp_equity >= 0.0:
                                                    logger.debug(
                                                        f"Found specific equity for coin '{target_currency}' in V5 structure ({acc_type}): {temp_equity:.4f}"
                                                    )
                                                    equity = temp_equity # Update with specific coin equity
                                                    found_equity = True
                                                    specific_equity_found = True # Mark that we found the exact coin
                                                    break # Found the specific currency equity, stop searching coin list
                                                else:
                                                    logger.warning(
                                                        f"Could not parse equity for coin {target_currency}: '{equity_str}'"
                                                    )
                                            else:
                                                logger.debug(
                                                    f"Coin {target_currency} found in V5 structure ({acc_type}), but no 'equity' field. Fields: {list(coin_info.keys())}"
                                                )
                                            break # Found the coin entry, stop searching coin list
                                    if specific_equity_found:
                                        break # Exit outer loop (account types) if specific coin equity found

                # If specific equity was found, exit the loop
                if specific_equity_found:
                    break

            except ccxt.ExchangeError as e:
                # Handle errors like "account type invalid" gracefully
                if "account type invalid" in str(e).lower() or "30084" in str(e): # 30084 is often related to account type mismatch
                     logger.debug(f"Account type '{acc_type}' not applicable or invalid: {e}. Trying next type...")
                else:
                     logger.warning(f"⚠️ Exchange error during fetch_balance with {acc_type}: {e}. Trying next type...")
                continue # Try next account type
            except Exception as e:
                logger.error(
                    f"💥 Unexpected error parsing balance response for {acc_type}: {e}"
                )
                continue # Try next account type


        # --- Fallback to Standard CCXT Parsing if specific V5 parsing failed ---
        if not found_equity: # If neither totalEquity nor specific coin equity was found via V5 parse
            logger.debug("V5 structure parsing failed or did not yield equity. Trying standard CCXT balance structure...")
            try:
                # Fetch balance without specific V5 params (let CCXT handle it)
                balance_data = exch.fetch_balance()
                logger.debug(f"Raw balance response (Default CCXT attempt): {str(balance_data)[:500]}...")

                # 1. Try standard CCXT 'total' field
                total_balance = balance_data.get("total", {})
                if isinstance(total_balance, dict) and target_currency in total_balance:
                    temp_equity = safe_float(total_balance.get(target_currency), -1.0)
                    if temp_equity >= 0.0:
                        logger.info(
                            f"✅ Fetched Equity ({target_currency}) using standard CCXT 'total' field: {Style.BRIGHT}{temp_equity:.4f}{Style.RESET_ALL}"
                        )
                        equity = temp_equity
                        found_equity = True
                    else:
                        logger.warning(
                            f"Could not parse equity from standard 'total' field for {target_currency}: value was {total_balance.get(target_currency)}"
                        )

                # 2. Fallback to 'free' + 'used' if 'total' failed
                if not found_equity:
                    logger.debug("Standard 'total' field failed. Trying 'free' + 'used'...")
                    free_balance = balance_data.get("free", {})
                    used_balance = balance_data.get("used", {})
                    if (
                        isinstance(free_balance, dict)
                        and isinstance(used_balance, dict)
                        and target_currency in free_balance # Check 'free' as primary indicator
                    ):
                        free = safe_float(free_balance.get(target_currency, 0.0))
                        used = safe_float(used_balance.get(target_currency, 0.0))
                        # Ensure both were parsed correctly (>= 0)
                        if free >= 0.0 and used >= 0.0:
                            temp_equity = free + used
                            # Check if free+used seems plausible (e.g., not zero when total wasn't)
                            if temp_equity > FLOAT_TOLERANCE:
                                logger.info(
                                    f"✅ Calculated Equity ({target_currency}) from 'free' + 'used': {Style.BRIGHT}{temp_equity:.4f}{Style.RESET_ALL} (Free: {free:.4f}, Used: {used:.4f})"
                                )
                                equity = temp_equity
                                found_equity = True
                            else:
                                logger.debug(f"'free' + 'used' resulted in zero or negative ({temp_equity:.4f}), likely not correct equity.")
                        else:
                            logger.warning(
                                f"Could not reliably parse equity from 'free'/'used' fields for {target_currency}."
                            )
            except Exception as e:
                 logger.error(f"💥 Error during standard CCXT balance fetch/parse: {e}")


        # --- Final Result ---
        if not found_equity:
            logger.warning(
                f"⚠️ Could not determine equity for {target_currency} from balance response after checking V5 ({account_types_to_try}) and standard structures. Returning 0.0."
            )
            logger.debug(
                f"Final balance data checked: {str(balance_data)[:500]}..." # Log truncated data from last attempt
            )
            return 0.0
        else:
            # Log final successful value once
            logger.info(
                f"✅ Final Equity ({target_currency}): {Style.BRIGHT}{equity:.4f}{Style.RESET_ALL}"
            )
            return equity

    except (
        ccxt.NetworkError,
        NewConnectionError,
        MaxRetryError,
        Urllib3TimeoutError,
        ccxt.RequestTimeout, # Added
    ) as e:
        logger.warning(f"🕸️ Network error fetching balance: {type(e).__name__} - {e}. Returning 0.0")
        return 0.0
    except ccxt.ExchangeError as e: # Catch errors outside the loop (e.g., if all attempts failed with ExchangeError)
        logger.error(
            f"🏛️ Exchange error fetching balance after all attempts: {e}. Returning 0.0"
        )
        return 0.0
    except (KeyError, TypeError, ValueError, IndexError) as e:
        logger.error(
            f"❌ Error parsing balance response structure outside loop for {target_currency}: {e}. Returning 0.0"
        )
        logger.debug(
            f"Balance response causing parsing error: {str(balance_data)[:500]}..."
        ) # Log raw data if debugging
        return 0.0
    except Exception as e:
        logger.exception(f"💥 Unexpected error fetching balance: {e}")
        return 0.0


def place_order_with_retry(
    order_func: Callable[[], dict[str, Any]],
    description: str,
    max_retries: int = DEFAULT_MAX_API_RETRIES,
    delay: int = DEFAULT_API_RETRY_DELAY,
) -> dict[str, Any] | None:
    """Attempts to place an order using the provided function, with retries for transient errors.
    Includes validation of the returned order structure and handles specific non-retriable errors.

    Args:
        order_func: A function (e.g., lambda) that calls the appropriate CCXT order creation method.
                    This function should raise ccxt exceptions on failure.
        description: A short description of the order being placed (for logging).
        max_retries: Maximum number of attempts.
        delay: Delay in seconds between retries.

    Returns:
        The order dictionary returned by CCXT if successful and validated, None otherwise.
    """
    last_exception = None
    for attempt in range(1, max_retries + 1):
        try:
            logger.info(
                f"⏳ Attempting to place {description} (Attempt {attempt}/{max_retries})..."
            )
            order = order_func()  # Execute the CCXT order call

            # Basic validation of returned order object (must be dict with an 'id' and 'status')
            # Status check helps confirm if the order was accepted/rejected immediately
            if (
                order
                and isinstance(order, dict)
                and order.get("id") # Check if ID exists and is non-empty
                and order.get("status") # Check if status exists
            ):
                order_id = order.get("id")
                order_status = order.get("status").lower() # CCXT standard status ('open', 'closed', 'canceled', 'rejected', etc.)
                order_type = order.get("type", "N/A")
                order_side = order.get("side", "N/A")
                order_amount = order.get("amount", "N/A")
                # Check Bybit specific status in 'info' for more detail (V5 uses 'orderStatus')
                info_status = str(order.get("info", {}).get("orderStatus", "N/A")).lower() # Lowercase for comparison

                # Check if status indicates immediate rejection or cancellation
                # Common rejection statuses: 'rejected', 'canceled', 'expired'
                # Common Bybit info statuses: 'rejected', 'cancelled', 'deactivated' (e.g. by risk control)
                rejected_statuses = ["rejected", "canceled", "cancelled", "expired", "deactivated"]
                if order_status in rejected_statuses or info_status in rejected_statuses:
                    logger.error(
                        f"❌ Order placement rejected or cancelled by exchange for '{description}'. Status: {order_status} (Info: {info_status}). Order ID: {order_id}. Response: {str(order)[:300]}"
                    )
                    send_sms(
                        f"Bot Alert ({config.symbol}): {description} REJECTED/CANCELLED by exchange. Status: {order_status}/{info_status}. Check logs."
                    )
                    return None  # Treat rejection as non-retriable failure

                # If not rejected, log success
                logger.info(
                    f"✅ Successfully placed {description}. Order ID: {order_id}, Type: {order_type}, Side: {order_side}, Amount: {order_amount}, Status: {order_status} (Info: {info_status})"
                )
                # Log full details only in debug for privacy/brevity
                logger.debug(f"Placed order details: {order}")
                return order
            else:
                # This case might indicate an issue with the exchange response parsing or an
                # unexpected return format from CCXT for this specific order type/exchange state.
                logger.error(
                    f"❌ Order placement function executed for '{description}', but returned invalid/incomplete order object (missing id or status, or not a dict): Type={type(order)}, Data={str(order)[:200]}..."
                )
                last_exception = ValueError(
                    f"Invalid order object received: {str(order)[:200]}"
                )  # Store error
                # Decide whether to retry or fail immediately on invalid response. Let's retry.
                if attempt < max_retries:
                    logger.info(
                        f"Retrying in {delay}s due to unexpected order response format..."
                    )
                    time.sleep(delay)
                    continue  # Go to next retry attempt
                else:
                    logger.error(
                        f"❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to place '{description}' after {max_retries} attempts due to invalid order response."
                    )
                    send_sms(
                        f"Bot Alert ({config.symbol}): Failed {description} placement (Invalid Response). Check system."
                    )
                    return None

        # --- Specific CCXT Error Handling (Prioritize Non-Retriable) ---
        except ccxt.InsufficientFunds as e:
            logger.error(
                f"💸 {description.capitalize()} placement {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL}: Insufficient funds. Check balance and margin requirements. Error: {e}"
            )
            send_sms(
                f"Bot Alert ({config.symbol}): Insufficient Funds for {description}."
            )
            return None  # No point retrying this specific error

        except ccxt.InvalidOrder as e:
            # This covers issues like invalid price, amount, order type, params, below minimums, precision errors etc.
            logger.error(
                f"❌ {description.capitalize()} placement {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL}: Invalid order parameters. Error: {e}"
            )
            logger.error(
                "   Check order size, price, SL/TP values, symbol limits (min amount/cost), precision, leverage, margin mode, and API parameters."
            )
            # Potentially log the parameters used (be careful with sensitive data if any)
            # logger.debug(f"   Order params causing error: {params}") # Requires passing params here or extracting from order_func if possible
            send_sms(
                f"Bot Alert ({config.symbol}): Invalid Order parameters for {description}. Check logs."
            )
            return None  # No point retrying invalid parameters

        except (
            ccxt.OrderNotFound
        ) as e:  # Should not happen on creation, but handle defensively
            logger.error(
                f"❌ {description.capitalize()} placement reported OrderNotFound immediately? This is unexpected. Error: {e}"
            )
            return None  # Treat as failure

        # --- Other Exchange Errors (Potentially Non-Retriable) ---
        except ccxt.ExchangeError as e:
            # Catch other specific exchange errors if known, otherwise log generically
            logger.error(
                f"🏛️ {description.capitalize()} placement {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} due to exchange error: {e}"
            )
            err_str = str(e).lower()
            # Check for specific Bybit V5 error codes/messages indicating non-retriable issues
            # Ref: https://bybit-exchange.github.io/docs/v5/error_code
            non_retriable_codes = [
                10001, # Parameter error / permission issues
                10004, # Invalid API key or IP whitelist issue
                10005, # Invalid API key permissions
                110001, # Order qty error (e.g., below min) -> handled by InvalidOrder?
                110007, # Insufficient balance -> handled by InsufficientFunds?
                110013, # Reduce-only order failed (e.g., no position)
                110025, # Margin mode issue (e.g., cannot set leverage)
                110045, # Position size exceeds limit
                110046, # Position value exceeds limit
                170101, # Risk limit error (buy)
                170102, # Risk limit error (sell)
                170131, # Risk limit error (position value)
                # Add more critical codes as needed
            ]
            non_retriable_keywords = [
                "risk control", "risk limit", "exceeds limit",
                "position limit", "margin mode", "reduce-only",
                "account type", "permission", "invalid api key",
                "parameter error", "qty too low", "value too low",
            ]
            is_non_retriable = any(str(code) in str(e) for code in non_retriable_codes) or \
                               any(keyword in err_str for keyword in non_retriable_keywords)

            if is_non_retriable:
                logger.error(
                    "   This appears to be a non-retriable configuration, risk limit, account, or logic issue."
                )
                send_sms(
                    f"Bot Alert ({config.symbol}): Non-retriable Exchange error on {description}: {str(e)[:60]}"
                )
                return None # Stop immediately
            else:
                # For other generic exchange errors, treat as potentially transient and retry
                logger.warning(f"   Treating as a potentially transient exchange error. Retrying...")
                last_exception = e
                if attempt < max_retries:
                    logger.info(f"Retrying in {delay}s...")
                    time.sleep(delay)
                    continue # Go to next retry attempt
                else:
                    logger.error(
                        f"❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to place {description} after {max_retries} attempts due to persistent ExchangeError: {e}"
                    )
                    send_sms(
                        f"Bot Alert ({config.symbol}): Failed {description} placement after retries (ExchangeError). Check system."
                    )
                    return None # Failed after all retries


        # --- Network and Rate Limit Errors (Retriable) ---
        except (
            ccxt.NetworkError,
            ccxt.RequestTimeout,
            ccxt.DDoSProtection,
            ccxt.ExchangeNotAvailable,
            NewConnectionError,
            MaxRetryError,
            Urllib3TimeoutError,
        ) as e:
            logger.warning(
                f"⏳ Transient error placing {description} on attempt {attempt}/{max_retries}: {type(e).__name__} - {e}"
            )
            last_exception = e
            if attempt < max_retries:
                logger.info(f"Retrying in {delay}s...")
                time.sleep(delay)
            else:
                logger.error(
                    f"❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to place {description} after {max_retries} attempts due to network/rate limit/availability issues: {e}"
                )
                send_sms(
                    f"Bot Alert ({config.symbol}): Failed {description} placement after retries (Network/Rate Limit/Unavailable). Check system."
                )
                return None  # Failed after all retries

        # --- Unexpected Errors ---
        except Exception as e:
            logger.exception(
                f"💥 Unexpected error during {description} placement: {e}"
            )  # Log traceback
            send_sms(
                f"Bot FATAL Alert ({config.symbol}): Unexpected error on {description} placement. Check logs! Error: {str(e)[:50]}"
            )
            return None  # Stop retrying on unexpected errors

    # Should only be reached if all retries failed due to transient errors handled above OR invalid response format after retries
    logger.error(
        f"❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to place {description} after {max_retries} attempts. Last error: {last_exception}"
    )
    # Send SMS again only if the final failure wasn't already alerted as critical/non-retriable
    # Check if last_exception exists and is one of the types that *would* have been retried to the end
    retriable_exception_types = (
            ccxt.NetworkError, ccxt.RequestTimeout, ccxt.DDoSProtection, ccxt.ExchangeNotAvailable,
            NewConnectionError, MaxRetryError, Urllib3TimeoutError, ValueError # Include ValueError for invalid format retry
    )
    if isinstance(last_exception, retriable_exception_types):
        send_sms(
            f"Bot Alert ({config.symbol}): Failed {description} placement after {max_retries} retries. Last error type: {type(last_exception).__name__}."
        )
    return None


def place_entry_order(
    exch: ccxt.Exchange | None,
    conf: Config,
    symbol: str,
    side: Side,
    current_atr: float,
    entry_price_estimate: float,  # Use last close price or current ticker price
) -> dict[str, Any] | None:
    """Calculates order parameters and places a market entry order with integrated Stop Loss
    and Take Profit using Bybit V5 API features via CCXT. Includes risk management,
    parameter formatting, validation, and dry run simulation.

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run).
        conf: The application configuration object.
        symbol: The market symbol (e.g., "BTCUSDT").
        side: The side of the order (Side.BUY or Side.SELL).
        current_atr: The current ATR value (must be positive and non-zero).
        entry_price_estimate: The estimated entry price for calculations (e.g., last close).

    Returns:
        The order dictionary if successfully placed (or simulated), None otherwise.
    """
    order_side_color = Fore.GREEN if side == Side.BUY else Fore.RED
    log_prefix = "DRY RUN: " if conf.dry_run else ""
    logger.info(
        f"{log_prefix}📐 Calculating parameters for {order_side_color}{side.value.upper()}{Style.RESET_ALL} market entry order on {symbol}..."
    )

    if not exch and not conf.dry_run:
        logger.error(
            f"❌ Cannot place entry order: Exchange object is not available and not in dry run mode."
        )
        return None

    # --- Validate Inputs ---
    if current_atr <= FLOAT_TOLERANCE:
        logger.error(
            f"❌ Cannot calculate order: Invalid ATR value ({current_atr:.8f}). Must be positive."
        )
        return None
    if entry_price_estimate <= FLOAT_TOLERANCE:
        logger.error(
            f"❌ Cannot calculate order: Invalid entry price estimate ({entry_price_estimate:.8f}). Must be positive."
        )
        return None

    # --- Get Equity & Determine Margin Currency ---
    margin_currency = "USDT"  # Default assumption
    base_currency = "BASE" # Placeholder
    if exch: # Need exchange object for market info, even in dry run for currency names
        try:
            market = exch.market(symbol)
            # Inverse contracts use base currency for margin, linear use quote.
            if market.get("inverse"):
                margin_currency = market.get("base", "UNKNOWN").upper()
                base_currency = market.get("base", "BASE").upper() # Base is base
            else: # Linear contract (assume USDT or quote)
                margin_currency = market.get("quote", "USDT").upper()
                base_currency = market.get("base", "BASE").upper()
            logger.debug(
                f"Determined margin currency: {margin_currency}, base currency: {base_currency}"
            )
        except Exception as e:
            logger.warning(
                f"Could not determine margin/base currency from market info: {e}. Defaulting to USDT margin, BASE base."
            )
            margin_currency = "USDT"
            base_currency = symbol.replace("USDT", "").replace("USD","")[:4] # Crude guess

    # Get Equity (uses margin_currency determined above)
    equity = get_balance(exch, currency=margin_currency)
    if equity <= FLOAT_TOLERANCE:
        logger.error(
            f"❌ Cannot place order: Equity for {margin_currency} is zero, negative, or could not be fetched."
        )
        if not conf.dry_run:
            logger.error(
                "   Please check your Bybit account balance and ensure the correct API key permissions (Read access for balance)."
            )
        return None
    logger.info(
        f"{log_prefix}Current Equity: {Style.BRIGHT}{equity:.2f} {margin_currency}{Style.RESET_ALL}"
    )

    # --- Calculate Stop Loss and Take Profit Prices ---
    distance_to_sl = current_atr * conf.sl_atr_mult
    distance_to_tp = current_atr * conf.tp_atr_mult

    if side == Side.BUY:
        sl_price = entry_price_estimate - distance_to_sl
        tp_price = entry_price_estimate + distance_to_tp
    else:  # Side.SELL
        sl_price = entry_price_estimate + distance_to_sl
        tp_price = entry_price_estimate - distance_to_tp

    # --- Validate SL/TP Prices ---
    # Check if SL crossed entry or TP is on the wrong side (can happen with large ATR/multipliers or volatile price)
    sl_too_close_or_crossed = (
        side == Side.BUY and sl_price >= entry_price_estimate - FLOAT_TOLERANCE
    ) or (side == Side.SELL and sl_price <= entry_price_estimate + FLOAT_TOLERANCE)
    tp_too_close_or_crossed = (
        side == Side.BUY and tp_price <= entry_price_estimate + FLOAT_TOLERANCE
    ) or (side == Side.SELL and tp_price >= entry_price_estimate - FLOAT_TOLERANCE)
    sl_zero_or_neg = sl_price <= FLOAT_TOLERANCE
    # TP can be negative for SELL if entry is low enough, but should not be zero or cross entry
    tp_zero_or_neg = tp_price <= FLOAT_TOLERANCE

    validation_errors = []
    if sl_too_close_or_crossed:
        validation_errors.append(
            f"Calculated SL ({sl_price:.5f}) is invalid (too close to or crossed entry estimate {entry_price_estimate:.5f}). SL Distance: {distance_to_sl:.5f}"
        )
    if tp_too_close_or_crossed:
        validation_errors.append(
            f"Calculated TP ({tp_price:.5f}) is invalid (too close to or crossed entry estimate {entry_price_estimate:.5f}). TP Distance: {distance_to_tp:.5f}"
        )
    if sl_zero_or_neg:
        validation_errors.append(
            f"Calculated SL price ({sl_price:.5f}) is zero or negative. Exchange will likely reject."
        )
    # Only flag zero/neg TP if it's truly invalid (e.g., for BUY or crossing entry for SELL)
    if tp_zero_or_neg and side == Side.BUY:
         validation_errors.append(
            f"Calculated TP price ({tp_price:.5f}) is zero or negative for BUY order. Invalid."
         )
    # Note: A negative TP for a SELL order might be valid if entry is low, but it shouldn't cross entry.
    # The tp_too_close_or_crossed check handles the crossing case.

    if validation_errors:
        logger.error("❌ Invalid SL/TP calculation:")
        logger.error(
            f"   Entry ≈ {entry_price_estimate:.5f}, Side: {side.value.upper()}"
        )
        logger.error(
            f"   ATR: {current_atr:.5f}, SL Mult: {conf.sl_atr_mult}, TP Mult: {conf.tp_atr_mult}"
        )
        for err in validation_errors:
            logger.error(f"   - {err}")
        logger.error(
            "   This might be due to extreme volatility, large ATR multipliers, bad entry price estimate, or insufficient precision. Order cancelled."
        )
        return None

    # --- Calculate Position Size (Risk Management) ---
    risk_amount_quote = (
        equity * conf.risk_per_trade
    )  # Amount to risk in quote currency (e.g., USDT)
    # Ensure distance_to_sl (price difference) is positive and non-zero before division
    if distance_to_sl <= FLOAT_TOLERANCE:
        logger.error(
            f"❌ Stop loss distance ({distance_to_sl:.8f}) is too small or zero after calculation. Cannot calculate position size."
        )
        return None

    # Size (in base currency) = (Amount to Risk in Quote) / (Distance to SL per unit of Base)
    # Ensure correct units. Risk is in QUOTE (e.g. USDT). SL distance is price diff (QUOTE per BASE). Result is BASE.
    amount_base_raw = risk_amount_quote / distance_to_sl

    logger.info(
        f"{log_prefix}Risking: {risk_amount_quote:.2f} {margin_currency} ({conf.risk_per_trade * 100:.1f}% of {equity:.2f} equity)"
    )
    logger.info(
        f"{log_prefix}SL Distance per unit: {distance_to_sl:.5f} {margin_currency}"
    )
    logger.info(
        f"{log_prefix}Calculated position size (raw): {Style.BRIGHT}{amount_base_raw:.8f}{Style.RESET_ALL} {base_currency}"
    )

    # --- Format for Exchange and Check Limits ---
    amount_str: str | None = None
    sl_price_str: str | None = None
    tp_price_str: str | None = None
    price_precision_digits: int = 8  # Default display precision
    amount_precision_digits: int = 8  # Default display precision
    min_amount: float | None = None
    max_amount: float | None = None
    min_cost: float | None = None
    max_cost: float | None = None

    try:
        if exch: # Need exchange object for market info (live or dry run)
            market = exch.market(symbol)
            precision = market.get("precision", {})
            limits = market.get("limits", {})

            # Format using CCXT helpers (handle both tick size and decimal places modes)
            amount_str = exch.amount_to_precision(symbol, amount_base_raw)
            sl_price_str = exch.price_to_precision(symbol, sl_price)
            tp_price_str = exch.price_to_precision(symbol, tp_price)

            # Log the precision used by the helpers if possible (from market data)
            amount_precision_raw = precision.get("amount")
            price_precision_raw = precision.get("price")
            if amount_precision_raw is not None:
                logger.debug(f"Amount precision info: {amount_precision_raw}")
            if price_precision_raw is not None:
                logger.debug(f"Price precision info: {price_precision_raw}")

            # Get Limits
            amount_limits = limits.get("amount", {})
            cost_limits = limits.get("cost", {}) # Min/max order value in quote currency
            min_amount = safe_float(amount_limits.get("min"), None) # Use None default if not found
            max_amount = safe_float(amount_limits.get("max"), None)
            min_cost = safe_float(cost_limits.get("min"), None)
            max_cost = safe_float(cost_limits.get("max"), None)

            # Log limits found
            logger.debug(f"Market Limits: Amount(min={min_amount}, max={max_amount}), Cost(min={min_cost}, max={max_cost})")

            # --- Check Minimums/Maximums ---
            amount_float = safe_float(amount_str) # Convert formatted string back to float for checks
            if (
                min_amount is not None and min_amount > FLOAT_TOLERANCE
                and amount_float < min_amount - FLOAT_TOLERANCE # Use tolerance
            ):
                logger.error(
                    f"❌ Calculated order size {amount_str} ({amount_float:.8f} {base_currency}) is below the minimum required {min_amount} for {symbol}. Cannot place order."
                )
                logger.info(
                    "   Consider adjusting leverage, risk per trade, or check symbol contract size/min order quantity."
                )
                return None
            if (
                max_amount is not None and max_amount > FLOAT_TOLERANCE
                and amount_float > max_amount + FLOAT_TOLERANCE
            ):
                logger.warning(
                    f"⚠️ Calculated order size {amount_str} ({amount_float:.8f}) exceeds max {max_amount}. Clamping size to maximum."
                )
                amount_str = exch.amount_to_precision(symbol, max_amount) # Reformat clamped value
                amount_float = safe_float(amount_str) # Update float value after clamping

            # Check Minimum/Maximum Cost (Value = Amount * Price) - Use entry estimate
            order_cost_estimate = amount_float * entry_price_estimate
            if (
                min_cost is not None and min_cost > FLOAT_TOLERANCE
                and order_cost_estimate < min_cost - FLOAT_TOLERANCE # Use tolerance
            ):
                logger.error(
                    f"❌ Estimated order cost ({order_cost_estimate:.2f} {margin_currency}) is below the minimum required {min_cost} {margin_currency} for {symbol}. Cannot place order."
                )
                logger.info("   Consider adjusting leverage or risk per trade.")
                return None
            if (
                max_cost is not None and max_cost > FLOAT_TOLERANCE
                and order_cost_estimate > max_cost + FLOAT_TOLERANCE
            ):
                logger.error(
                    f"❌ Estimated order cost ({order_cost_estimate:.2f} {margin_currency}) exceeds the maximum allowed {max_cost} {margin_currency} for {symbol}. Cannot place order."
                )
                logger.info("   This usually requires reducing risk per trade or leverage.")
                return None

            # Use market precision for logging display if available
            with contextlib.suppress(Exception): # Safely try to get decimal places
                price_prec_info = market.get("precision", {}).get("price")
                amount_prec_info = market.get("precision", {}).get("amount")
                if isinstance(price_prec_info, int): price_precision_digits = price_prec_info
                elif isinstance(price_prec_info, float): price_precision_digits = abs(int(round(math.log10(price_prec_info)))) if price_prec_info > 0 else 8
                if isinstance(amount_prec_info, int): amount_precision_digits = amount_prec_info
                elif isinstance(amount_prec_info, float): amount_precision_digits = abs(int(round(math.log10(amount_prec_info)))) if amount_prec_info > 0 else 8

            logger.info(
                f"{log_prefix}Formatted Size: {amount_str} {base_currency}, SL: {sl_price_str}, TP: {tp_price_str}"
            )

        else:  # Should not happen if config validation requires exchange init even for dry run, but handle defensively
            logger.warning("Exchange object not available during parameter formatting (unexpected). Using default precision.")
            amount_str = f"{amount_base_raw:.{amount_precision_digits}f}"
            sl_price_str = f"{sl_price:.{price_precision_digits}f}"
            tp_price_str = f"{tp_price:.{price_precision_digits}f}"
            logger.info(
                f"{log_prefix}Simulated Formatting (Default Prec): Size: {amount_str} {base_currency}, SL: {sl_price_str}, TP: {tp_price_str}"
            )
            # Cannot check limits in this case

        # Final check: ensure strings are set and represent valid numbers
        if not all([amount_str, sl_price_str, tp_price_str]):
             raise ValueError("One or more formatted order parameters are None.")
        if safe_float(amount_str) <= FLOAT_TOLERANCE:
             raise ValueError(f"Formatted amount '{amount_str}' is zero or negative.")
        if safe_float(sl_price_str) <= FLOAT_TOLERANCE:
             raise ValueError(f"Formatted SL price '{sl_price_str}' is zero or negative.")
        # TP check: must be positive for BUY, can be negative for SELL but should not be zero
        if safe_float(tp_price_str) <= FLOAT_TOLERANCE and side == Side.BUY:
             raise ValueError(f"Formatted TP price '{tp_price_str}' is zero or negative for BUY order.")
        if abs(safe_float(tp_price_str)) < FLOAT_TOLERANCE and side == Side.SELL: # Check abs value for zero TP on SELL
             raise ValueError(f"Formatted TP price '{tp_price_str}' is zero for SELL order.")

    except (ccxt.ExchangeError, ValueError, TypeError, KeyError) as e:
        logger.error(
            f"❌ Error formatting order parameters or checking limits for {symbol}: {e}"
        )
        return None
    except Exception as e:
        logger.exception(
            f"💥 Unexpected error during order parameter formatting/validation: {e}"
        )
        return None

    # --- Prepare Order Parameters (Bybit V5 for Market Order with SL/TP) ---
    # Determine category consistently (already done for currency lookup)
    category = "linear" if not market.get("inverse") else "inverse"

    params = {
        "category": category,
        "stopLoss": sl_price_str,  # String required by Bybit API
        "takeProfit": tp_price_str,  # String required by Bybit API
        "slTriggerBy": "LastPrice",  # Options: MarkPrice, IndexPrice, LastPrice (check Bybit docs for defaults/recommendations)
        "tpTriggerBy": "LastPrice",  # Options: MarkPrice, IndexPrice, LastPrice
        "tpslMode": "Full",  # Options: 'Full' (entire position), 'Partial'. Default is usually 'Full'. Ensure this matches account settings.
        # 'slOrderType': 'Market',   # Default is Market for SL/TP triggers on Bybit V5
        # 'tpOrderType': 'Market',   # Default is Market
        # Add client order ID for better tracking?
        # "orderLinkId": f"pyrm_{side.value}_{int(time.time() * 1000)}"
    }

    # Construct description for logging and retry wrapper
    price_fmt = f".{price_precision_digits}f"
    order_description = (
        f"{order_side_color}{side.value.upper()}{Style.RESET_ALL} {Style.BRIGHT}{amount_str} {symbol}{Style.NORMAL} Market Entry "
        f"(Est. Entry≈{entry_price_estimate:{price_fmt}}, SL={Fore.RED}{sl_price_str}{Style.RESET_ALL}, TP={Fore.GREEN}{tp_price_str}{Style.RESET_ALL})"
    )
    logger.info(f"{log_prefix}Prepared Order: {order_description}")

    # --- Execute Order ---
    if conf.dry_run:
        logger.warning(f"{log_prefix}Skipping actual placement of: {order_description}")
        # Return mock order data consistent with successful placement
        ts = int(time.time() * 1000)
        mock_id = f"dryrun_{ts}"
        iso_ts = ccxt.Exchange.iso8601(ts) # Use static method for ISO formatting
        # Simulate filled market order
        filled_amount = safe_float(amount_str)
        # Simulate fill price slightly different from estimate (slippage)
        slippage_factor = 0.0005 # 0.05% slippage simulation
        avg_price = (
            entry_price_estimate * (1 + slippage_factor)
            if side == Side.BUY
            else entry_price_estimate * (1 - slippage_factor)
        )
        # Ensure simulated price is positive
        avg_price = max(avg_price, FLOAT_TOLERANCE)
        # Format avg_price using exchange precision for realism in mock
        avg_price_str = exch.price_to_precision(symbol, avg_price) if exch else f"{avg_price:{price_fmt}}"
        avg_price = safe_float(avg_price_str) # Use formatted price

        cost = filled_amount * avg_price
        # Mock fee (e.g., 0.055% taker fee on Bybit)
        fee_rate = 0.00055
        fee_cost = abs(cost * fee_rate)

        # Create a mock order structure similar to CCXT's unified format
        mock_order = {
            "info": { # Mimic Bybit V5 structure loosely
                "orderId": mock_id,
                "symbol": symbol,
                "side": side.value.capitalize(),
                "orderType": "Market",
                "orderStatus": "Filled", # Market orders fill immediately
                "stopLoss": sl_price_str,
                "takeProfit": tp_price_str,
                "category": category,
                "avgPrice": avg_price_str,
                "cumExecQty": amount_str, # Use formatted string amount
                "cumExecValue": str(cost),
                "tpslMode": "Full",
                "orderLinkId": f"dryrun_{side.value}_{ts}",
                "createdTime": str(ts),
                "updatedTime": str(ts),
                 # Add simulated fee info if possible
                "cumExecFee": str(fee_cost),
            },
            "id": mock_id,
            "clientOrderId": f"dryrun_{side.value}_{ts}",
            "timestamp": ts,
            "datetime": iso_ts,
            "lastTradeTimestamp": ts,
            "symbol": symbol,
            "type": "market",
            "timeInForce": "IOC", # ImmediateOrCancel typical for market
            "postOnly": False,
            "reduceOnly": False,
            "side": side.value,
            "price": None, # Market order price is None until filled
            "stopPrice": None,
            "triggerPrice": None,
            "stopLossPrice": safe_float(sl_price_str), # Store SL/TP prices if available
            "takeProfitPrice": safe_float(tp_price_str),
            "amount": filled_amount,
            "filled": filled_amount,
            "remaining": 0.0,
            "cost": cost,
            "average": avg_price,
            "status": "closed", # Market orders usually fill immediately and close
            "fee": {"cost": fee_cost, "currency": margin_currency, "rate": fee_rate, "type": "taker"},
            "trades": [ # Simulate a single fill trade
                 {
                    'id': f'dryrun_trade_{ts}',
                    'order': mock_id,
                    'info': {}, # Add mock trade info if needed
                    'timestamp': ts,
                    'datetime': iso_ts,
                    'symbol': symbol,
                    'type': 'market',
                    'side': side.value,
                    'takerOrMaker': 'taker',
                    'price': avg_price,
                    'amount': filled_amount,
                    'cost': cost,
                    'fee': {"cost": fee_cost, "currency": margin_currency, "rate": fee_rate},
                 }
            ],
        }
        logger.debug(f"DRY RUN: Mock order created: {mock_order}")
        return mock_order
    else:
        # Ensure exchange object is valid before proceeding
        if not exch:
            logger.error("❌ Cannot place live order: Exchange object is invalid.")
            return None

        # Define the function to be passed to the retry wrapper
        def create_entry_order_func():
            # Use create_order for market orders with integrated SL/TP in Bybit V5
            final_amount = safe_float(amount_str) # Ensure amount is float
            logger.debug(
                f"Calling exch.create_order with: symbol={symbol}, type='market', side={side.value}, amount={final_amount}, params={params}"
            )
            # Re-check amount validity before sending
            if final_amount <= FLOAT_TOLERANCE:
                raise ccxt.InvalidOrder(f"Calculated amount {final_amount} is too small to place order.")
            # Re-check minimums here as a final safeguard
            if min_amount is not None and final_amount < min_amount - FLOAT_TOLERANCE:
                raise ccxt.InvalidOrder(f"Amount {final_amount} is below minimum {min_amount} for {symbol}.")
            # Cost check is harder here without live price, rely on previous check and InsufficientFunds exception.

            return exch.create_order(
                symbol, "market", side.value, final_amount, params=params
            )

        # Attempt placement with retries
        order = place_order_with_retry(create_entry_order_func, order_description)

        if order:
            # Optional: Verify SL/TP were accepted by checking the order info carefully
            # Access info safely
            order_info = order.get("info", {})
            returned_sl = order_info.get("stopLoss") if isinstance(order_info, dict) else None
            returned_tp = order_info.get("takeProfit") if isinstance(order_info, dict) else None

            # Compare formatted strings for safety due to potential float inaccuracies
            sl_match = returned_sl == sl_price_str
            tp_match = returned_tp == tp_price_str

            logger.info(
                f"Entry order placed successfully for {symbol}. Order ID: {order.get('id')}."
            )
            if sl_match and tp_match:
                logger.info(
                    f"   SL ({sl_price_str}) and TP ({tp_price_str}) confirmed in order response."
                )
            else:
                # Log warning, but don't treat as failure if order ID exists
                logger.warning(
                    f"⚠️ SL/TP in order response (SL='{returned_sl}', TP='{returned_tp}') may not exactly match calculated (SL='{sl_price_str}', TP='{tp_price_str}'). Verify on exchange."
                )
                # You might want to send an alert here too.
                send_sms(f"Bot WARNING ({config.symbol}): SL/TP mismatch on entry order {order.get('id')}. Please check.")
            return order
        else:
            logger.error(
                f"❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to place {side.value.upper()} market entry order for {symbol} after retries or due to critical error."
            )
            # SMS alert should have been sent by place_order_with_retry on failure
            return None


def close_position(
    exch: ccxt.Exchange | None,
    conf: Config,
    symbol: str,
    position_side: PositionSide,
    position_amount: float,
) -> dict[str, Any] | None:
    """Closes an existing position using a reduce-only market order (Bybit V5).

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run).
        conf: The application configuration object.
        symbol: The market symbol (e.g., "BTCUSDT").
        position_side: The side of the position to close (PositionSide.LONG or PositionSide.SHORT).
        position_amount: The amount (size) of the position to close (must be positive).

    Returns:
        The closing order dictionary if successfully placed (or simulated), None otherwise.
        Returns None if no position needs closing or if amount formatting fails.
    """
    log_prefix = "DRY RUN: " if conf.dry_run else ""

    if not exch and not conf.dry_run:
        logger.error(
            "❌ Cannot close position: Exchange object is not available and not in dry run mode."
        )
        return None

    if position_side == PositionSide.NONE or position_amount <= FLOAT_TOLERANCE:
        logger.info(
            f"{log_prefix}No position or zero amount specified ({position_side.value}, {position_amount:.8f}), nothing to close."
        )
        return None # Indicate nothing was done, not necessarily an error

    # Determine the side of the closing order (opposite of the position)
    side_to_close = Side.SELL if position_side == PositionSide.LONG else Side.BUY
    close_side_color = Fore.RED if side_to_close == Side.SELL else Fore.GREEN
    position_side_color = Fore.GREEN if position_side == PositionSide.LONG else Fore.RED

    logger.info(
        f"{log_prefix}🎬 Preparing to close {position_side_color}{position_side.value}{Style.RESET_ALL} position for {symbol}..."
    )

    amount_str: str | None = None
    amount_precision_digits: int = 8  # Default display precision
    base_currency = "BASE"  # Placeholder
    min_amount: float | None = None

    try:
        if exch: # Need exchange for market info
            market = exch.market(symbol)
            base_currency = market.get("base", base_currency)
            # Use amount_to_precision for formatting
            amount_str = exch.amount_to_precision(symbol, position_amount)
            # Get min amount for validation
            min_amount = safe_float(
                market.get("limits", {}).get("amount", {}).get("min"), None
            )
            # Get display precision
            with contextlib.suppress(Exception): # Safely try to get decimal places
                amount_prec_info = market.get("precision", {}).get("amount")
                if isinstance(amount_prec_info, int): amount_precision_digits = amount_prec_info
                elif isinstance(amount_prec_info, float): amount_precision_digits = abs(int(round(math.log10(amount_prec_info)))) if amount_prec_info > 0 else 8

            logger.info(
                f"{log_prefix}  Position Amount: {position_amount:.{amount_precision_digits}f} {base_currency}, Formatted Close Amount: {amount_str}"
            )
            # Basic check: ensure formatted amount is not zero after precision applied
            amount_float = safe_float(amount_str)
            if amount_float <= FLOAT_TOLERANCE:
                logger.error(
                    f"❌ Position amount {position_amount:.8f} is zero or negative after applying precision for {symbol}. Cannot place close order."
                )
                return None
            # Check against minimum if available
            if (
                min_amount is not None and min_amount > FLOAT_TOLERANCE
                and amount_float < min_amount - FLOAT_TOLERANCE
            ):
                logger.error(
                    f"❌ Close amount {amount_str} is below minimum order size {min_amount} for {symbol}. Cannot place close order automatically."
                )
                # This situation is tricky - maybe the position is too small to close via API? Manual intervention needed.
                send_sms(
                    f"Bot CRITICAL ({config.symbol}): Position size {amount_str} is BELOW MINIMUM {min_amount} to close via API! Manual intervention required!"
                )
                return None # Prevent placing order that will fail

        else: # Should not happen if exchange is required even for dry run currency names
             logger.warning("Exchange object not available during close formatting (unexpected). Using default precision.")
             amount_str = f"{position_amount:.{amount_precision_digits}f}" # Simulate formatting
             logger.info(f"{log_prefix}  Simulated Close Amount: {amount_str}")
             if safe_float(amount_str) <= FLOAT_TOLERANCE:
                 logger.error("❌ Simulated position amount is too small. Cannot simulate close.")
                 return None

        if not amount_str: # Should be caught by checks above, but safety net
            raise ValueError("Failed to format close order amount string.")

    except (ccxt.ExchangeError, ValueError, TypeError, KeyError) as e:
        logger.error(
            f"❌ Error formatting close order amount {position_amount} for {symbol}: {e}"
        )
        return None
    except Exception as e:
        logger.exception(
            f"💥 Unexpected error during close order amount formatting: {e}"
        )
        return None

    # If amount formatting failed, return None
    if not amount_str:
         logger.error("❌ Close order amount string is empty after formatting attempts.")
         return None

    order_description = (
        f"Close {position_side_color}{position_side.value}{Style.RESET_ALL} ({Style.BRIGHT}{amount_str} {symbol}{Style.NORMAL}) "
        f"with {close_side_color}{side_to_close.value.upper()}{Style.RESET_ALL} Market ({Fore.MAGENTA}Reduce-Only{Style.RESET_ALL})"
    )
    logger.info(f"{log_prefix}  Action: {order_description}")

    # Bybit V5 uses create_order with reduceOnly param
    # Determine category consistently
    category = "linear" # Default assumption
    if exch:
        try:
            market = exch.market(symbol)
            if market.get("inverse"):
                category = "inverse"
        except Exception:
            pass

    params = {
        "category": category,
        "reduceOnly": True,  # Crucial parameter to ensure it only closes/reduces position
        # Consider adding a unique client order ID for closing orders if needed for tracking
        # "orderLinkId": f"pyrm_close_{symbol}_{int(time.time() * 1000)}"
    }

    if conf.dry_run:
        logger.warning(f"{log_prefix}Skipping actual placement of: {order_description}")
        # Return mock close order data
        ts = int(time.time() * 1000)
        mock_id = f"dryrun_close_{ts}"
        iso_ts = ccxt.Exchange.iso8601(ts)
        filled_amount = safe_float(amount_str)
        # Mock cost/average requires estimating close price. Use a simple estimate.
        # Fetch current price estimate for mock close
        mock_close_price = 60500 # Default fallback
        if exch:
            try:
                ticker = exch.fetch_ticker(symbol)
                last_price = safe_float(ticker.get('last'))
                if last_price > FLOAT_TOLERANCE: mock_close_price = last_price
            except Exception: pass # Ignore errors fetching ticker for mock

        mock_cost = filled_amount * mock_close_price
        fee_rate = 0.00055 # Taker fee
        fee_cost = abs(mock_cost * fee_rate)
        margin_currency = "USDT" # Assume for mock
        if exch:
            try: margin_currency = exch.market(symbol).get('quote', 'USDT').upper()
            except Exception: pass

        # Mock order structure
        mock_order = {
            "info": {
                "orderId": mock_id,
                "symbol": symbol,
                "side": side_to_close.value.capitalize(),
                "orderType": "Market",
                "orderStatus": "Filled",
                "reduceOnly": True,
                "category": category,
                "cumExecQty": amount_str,
                "avgPrice": str(mock_close_price),
                "cumExecValue": str(mock_cost),
                "orderLinkId": f"dryrun_close_{side_to_close.value}_{ts}",
                "createdTime": str(ts),
                "updatedTime": str(ts),
                "cumExecFee": str(fee_cost),
            },
            "id": mock_id,
            "clientOrderId": f"dryrun_close_{side_to_close.value}_{ts}",
            "timestamp": ts,
            "datetime": iso_ts,
            "lastTradeTimestamp": ts,
            "symbol": symbol,
            "type": "market",
            "timeInForce": "IOC",
            "postOnly": False,
            "reduceOnly": True,
            "side": side_to_close.value,
            "price": None, # Market order
            "stopPrice": None,
            "triggerPrice": None,
            "amount": filled_amount,
            "filled": filled_amount,
            "remaining": 0.0,
            "cost": mock_cost,
            "average": mock_close_price,
            "status": "closed",
            "fee": {"cost": fee_cost, "currency": margin_currency, "rate": fee_rate, "type": "taker"},
            "trades": [ # Simulate a single fill trade
                 {
                    'id': f'dryrun_close_trade_{ts}',
                    'order': mock_id,
                    'info': {},
                    'timestamp': ts,
                    'datetime': iso_ts,
                    'symbol': symbol,
                    'type': 'market',
                    'side': side_to_close.value,
                    'takerOrMaker': 'taker',
                    'price': mock_close_price,
                    'amount': filled_amount,
                    'cost': mock_cost,
                    'fee': {"cost": fee_cost, "currency": margin_currency, "rate": fee_rate},
                 }
            ],
        }
        logger.debug(f"DRY RUN: Mock close order created: {mock_order}")
        return mock_order
    else:
        # Ensure exchange object is valid
        if not exch:
            logger.error("❌ Cannot place live close order: Exchange object is invalid.")
            return None

        # Define the function for the retry wrapper
        def create_close_order_func():
            final_amount = safe_float(amount_str)
            logger.debug(
                f"Calling exch.create_order with: symbol={symbol}, type='market', side={side_to_close.value}, amount={final_amount}, params={params}"
            )
            # Final validation before sending
            if final_amount <= FLOAT_TOLERANCE:
                raise ccxt.InvalidOrder(f"Calculated close amount {final_amount} is too small.")
            if min_amount is not None and final_amount < min_amount - FLOAT_TOLERANCE:
                # Logged above, raise exception to prevent sending
                raise ccxt.InvalidOrder(f"Close amount {final_amount} below minimum {min_amount}.")
            return exch.create_order(
                symbol, "market", side_to_close.value, final_amount, params=params
            )

        # Attempt placement with retries
        order = place_order_with_retry(create_close_order_func, order_description)

        if order:
            logger.info(
                f"✅ Position close order placed successfully for {symbol}. Order ID: {order.get('id')}"
            )
            return order
        else:
            logger.error(f"❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to place position close order for {symbol}.")
            # CRITICAL ALERT - Failure to close can lead to significant losses
            send_sms(
                f"Bot CRITICAL ALERT ({config.symbol}): FAILED to close {position_side.value} position ({amount_str})! Manual intervention likely required."
            )
            return None


# --- Main Trading Logic ---
# Global state for dry run position simulation (simple version)
# Needs to store side, amount, and entry price
dry_run_position: dict[str, Any] = { # Use Any for flexibility, ensure types later
    "side": PositionSide.NONE,
    "amount": 0.0,
    "entry_price": 0.0,
}


def trade_logic(exch: ccxt.Exchange | None, conf: Config) -> bool:
    """Contains the core trading logic for one cycle.

    1. Fetches necessary data (OHLCV, Order Book, Ticker).
    2. Calculates indicators (ATR, Supertrends, Volume Ratio, OB Pressure).
    3. Checks current position status (live or simulated for dry run).
    4. Generates entry/exit/reversal signals based on indicator confluence.
    5. Executes trading decisions (enter, exit, hold, reverse) using helper functions.
    6. Updates dry run state if applicable.

    Args:
        exch: The configured ccxt.Exchange instance (can be None for dry run).
        conf: The application configuration object.

    Returns:
        True if the cycle executed without critical internal errors (even if no action taken),
        False if a critical error occurred preventing normal execution of the cycle logic.
    """
    global dry_run_position  # Access the simple global state for dry run

    if not exch and not conf.dry_run:
        logger.error(
            "Trade logic skipped: Exchange object is not available and not in dry run mode."
        )
        return False  # Indicate failure to execute cycle normally

    log_prefix = "DRY RUN: " if conf.dry_run else ""
    logger.info(
        f"{log_prefix}{Fore.CYAN}{Style.BRIGHT}--- Starting Trade Logic Cycle for {conf.symbol} ({conf.timeframe}) ---{Style.RESET_ALL}"
    )

    # --- 1. Data Fetching ---
    # Determine max lookback needed for all indicators + buffer
    required_data_length = (
        max(
            conf.long_st_period + 2, # Stateless ST needs period + 2
            conf.short_st_period + 2,
            DEFAULT_VOLUME_LONG_PERIOD, # Volume ratio needs long period
            conf.long_st_period + 1, # ATR needs period + 1
        )
        + 5 # Add buffer for safety/potential edge cases
    )
    logger.debug(f"Required OHLCV length for calculations: {required_data_length}")
    ohlcv = fetch_ohlcv(
        exch, conf.symbol, timeframe=conf.timeframe, limit=required_data_length
    )

    # Absolute minimum required candles for ANY calculation (re-check min needed)
    min_required_candles = max(
        conf.long_st_period + 2, # Supertrend
        conf.short_st_period + 2,
        DEFAULT_VOLUME_LONG_PERIOD, # Volume Ratio
        conf.long_st_period + 1, # ATR for risk
    )

    if not ohlcv or len(ohlcv) < min_required_candles:
        logger.warning(
            f"⚠️ Insufficient valid OHLCV data for calculations. Need at least {min_required_candles} candles, got {len(ohlcv) if ohlcv else 0}. Skipping cycle."
        )
        # If dry run and no data, fetch_ohlcv already provided mock data if exch was None.
        # If exch exists but returned insufficient data, this is a real data issue.
        return True  # Cycle skipped due to data issue, but not a critical failure of the bot itself

    # --- Extract Current Price (use last close from OHLCV as primary estimate) ---
    last_close_price: float | None = None
    last_timestamp_ms: int | None = None
    try:
        last_candle = ohlcv[-1]
        last_close_price = safe_float(last_candle[OHLCV_INDEX["close"]])
        last_timestamp_ms = int(last_candle[OHLCV_INDEX["timestamp"]])
        current_dt_str = (
            ccxt.Exchange.iso8601(last_timestamp_ms) if last_timestamp_ms else "N/A"
        )

        if last_close_price <= FLOAT_TOLERANCE:
            raise ValueError(f"Last close price ({last_close_price}) is zero or negative.")
        # Check timestamp freshness (e.g., is it too old?)
        time_now_ms = int(time.time() * 1000)
        if last_timestamp_ms and (time_now_ms - last_timestamp_ms > 5 * 60 * 1000): # Warn if > 5 mins old
             logger.warning(f"⚠️ Last candle timestamp ({current_dt_str}) seems old (> 5 min). Data might be stale.")

    except (IndexError, KeyError, TypeError, ValueError) as e:
        logger.error(
            f"❌ Could not extract valid last close price from OHLCV data: {e}. Skipping cycle."
        )
        logger.debug(f"Last OHLCV candle data: {ohlcv[-1] if ohlcv else 'None'}")
        return False  # Failure to get price is critical for decisions

    # --- Fetch Ticker for potentially more up-to-date price ---
    # Use ticker 'last' price if available and seems valid, otherwise fallback to OHLCV close
    current_price = last_close_price  # Default to last close
    ticker_price: float | None = None
    ticker_fetch_success = False
    try:
        if exch:  # Only fetch ticker in live mode or if needed for dry run refinement
            # Specify category for V5 ticker fetch
            params = {'category': 'linear'}
            try:
                if exch.market(conf.symbol).get('inverse'):
                    params['category'] = 'inverse'
            except Exception: pass

            ticker = exch.fetch_ticker(conf.symbol, params=params)
            ticker_price = safe_float(ticker.get("last"), None) # Use None default to check if fetch worked
            if ticker_price is not None and ticker_price > FLOAT_TOLERANCE:
                ticker_fetch_success = True
                # Basic sanity check: is ticker price wildly different from close? (e.g., > 5% diff)
                price_diff_ratio = abs(ticker_price - last_close_price) / last_close_price
                if price_diff_ratio < 0.05:  # If difference is less than 5%
                    current_price = ticker_price  # Use ticker price
                    logger.debug(f"Using ticker last price ({ticker_price:.5f}) as current price.")
                else:
                    logger.warning(
                        f"⚠️ Ticker price ({ticker_price:.5f}) differs significantly (>5%) from last close ({last_close_price:.5f}). Using last close price ({last_close_price:.5f}) for safety."
                    )
                    current_price = last_close_price # Fallback to close price
            else:
                logger.debug(
                    "Ticker 'last' price unavailable or invalid, using last OHLCV close price."
                )
                current_price = last_close_price
        elif config.dry_run:
            # In dry run, we might simulate slight price change from last close for realism
            current_price = last_close_price * (1 + (time.time() % 0.0002 - 0.0001)) # Tiny random fluctuation
            current_price = max(current_price, FLOAT_TOLERANCE) # Ensure positive
            ticker_fetch_success = True # Simulate success
            logger.debug(f"DRY RUN: Simulating current price based on last close: {current_price:.5f}")

    except (ccxt.NetworkError, ccxt.ExchangeError, ccxt.RequestTimeout) as e:
        logger.warning(f"⚠️ Could not fetch ticker price: {type(e).__name__} - {e}. Using last OHLCV close price.")
        current_price = last_close_price
    except Exception as e:
        logger.error(f"💥 Unexpected error fetching ticker: {e}. Using last OHLCV close price.")
        current_price = last_close_price

    # Get price precision for logging display
    price_precision_digits = 8  # Default
    if exch: # Need exchange for market info
        with contextlib.suppress(Exception): # Safely try to get decimal places
            market = exch.market(conf.symbol)
            price_prec_info = market.get("precision", {}).get("price")
            if isinstance(price_prec_info, int): price_precision_digits = price_prec_info
            elif isinstance(price_prec_info, float): price_precision_digits = abs(int(round(math.log10(price_prec_info)))) if price_prec_info > 0 else 8
    price_format = f".{price_precision_digits}f" # Format string

    logger.info(
        f"{log_prefix}Last Candle: Time={current_dt_str}, Close={last_close_price:{price_format}}"
    )
    logger.info(
        f"{log_prefix}Current Price Estimate (using {'Ticker' if ticker_fetch_success and current_price == ticker_price else ('Last Close' if ticker_fetch_success else 'Last Close (Ticker Failed)')}): {Style.BRIGHT}{current_price:{price_format}}{Style.RESET_ALL}"
    )

    # --- 2. Indicator Calculations ---
    logger.info(f"{log_prefix}Calculating indicators...")
    # Use long period ATR for risk calculation consistency
    current_atr = calculate_atr(ohlcv, period=conf.long_st_period) # Check length handled inside function

    # Calculate both Supertrends (check data length requirements inside the function)
    short_st_val, short_st_up = calculate_supertrend(
        ohlcv, conf.short_st_period, conf.st_multiplier
    )
    long_st_val, long_st_up = calculate_supertrend(
        ohlcv, conf.long_st_period, conf.st_multiplier
    )
    # Calculate volume ratio
    volume_ratio = fetch_volume_ratio(
        ohlcv,
        short_period=DEFAULT_VOLUME_SHORT_PERIOD,
        long_period=DEFAULT_VOLUME_LONG_PERIOD,
    )
    # Calculate order book pressure
    ob_pressure = fetch_order_book_pressure(
        exch, conf.symbol, depth=DEFAULT_ORDER_BOOK_DEPTH
    )

    # Check if all essential indicators required for signals were calculated successfully
    # ATR is crucial for ANY order placement. Others for signal generation.
    essential_indicators = {
        "ATR_Risk": current_atr,    # Need ATR for placing ANY order
        "ShortST_Up": short_st_up,  # Need ST trend for signals
        "ShortST_Val": short_st_val,# Need ST value for price comparison
        "LongST_Up": long_st_up,    # Need ST trend for signals
        "LongST_Val": long_st_val,  # Need ST value for price comparison
        "VolumeRatio": volume_ratio,# Need Vol for signals
        "OBPressure": ob_pressure,  # Need OB for signals
    }
    # Check for None values in essential indicators
    missing_indicators = [
        name for name, val in essential_indicators.items() if val is None
    ]
    if missing_indicators:
        logger.warning(
            f"⚠️ One or more essential indicators failed to calculate: {', '.join(missing_indicators)}. Skipping signal generation and actions this cycle."
        )
        # Log details of indicator values if debugging
        logger.debug(f"Indicator values at failure point: {essential_indicators}")
        # If ATR failed, we cannot place orders even if signals were somehow generated.
        if current_atr is None:
            logger.error("   ATR calculation failed, cannot determine risk/SL/TP.")
        return True  # Cycle skipped due to indicator failure, not bot crash

    logger.info(f"{log_prefix}Indicators calculated successfully.")

    # --- 3. Position Check ---
    position_side = PositionSide.NONE
    position_amount = 0.0
    entry_price = 0.0

    if conf.dry_run:
        # Use the simulated position state from the global variable
        # Ensure types are correct after retrieval
        position_side = dry_run_position.get("side", PositionSide.NONE)
        position_amount = safe_float(dry_run_position.get("amount", 0.0))
        entry_price = safe_float(dry_run_position.get("entry_price", 0.0))
        if not isinstance(position_side, PositionSide): position_side = PositionSide.NONE # Ensure enum type
        logger.info("DRY RUN: Using simulated position state.")
    else:
        # Fetch live position state
        pos_side_live, pos_amount_live, entry_price_live = get_position(
            exch, conf.symbol
        )
        # Use the returned state directly. get_position handles errors and returns NONE/0/0 on failure.
        position_side = pos_side_live
        position_amount = pos_amount_live
        entry_price = entry_price_live
        if (
            pos_side_live == PositionSide.NONE
            and pos_amount_live == 0.0
            and entry_price_live == 0.0
        ):
            # This is the expected return for no position OR if get_position failed.
            # get_position should have logged the reason if it failed.
            logger.debug(
                "get_position returned NONE/0/0, proceeding as if no position exists (check previous logs for potential errors)."
            )

    pos_side_color = (
        Fore.GREEN
        if position_side == PositionSide.LONG
        else (Fore.RED if position_side == PositionSide.SHORT else Fore.WHITE)
    )
    entry_price_str = (
        f"{entry_price:{price_format}}" if entry_price > FLOAT_TOLERANCE else "N/A"
    )
    logger.info(
        f"{log_prefix}Current Position: Side={pos_side_color}{Style.BRIGHT}{position_side.value}{Style.RESET_ALL}, Amount={Style.BRIGHT}{position_amount:.8f}{Style.NORMAL}, Entry={Style.BRIGHT}{entry_price_str}{Style.RESET_ALL}"
    )

    # --- 4. Signal Generation ---
    logger.info(f"{log_prefix}Generating signals based on calculated indicators...")
    # Check conditions using the calculated indicators (which are confirmed not None here)

    # --- Long Signal Conditions ---
    # 1. Trend Confirmation: Both Supertrends must be bullish (is_uptrend = True)
    #    AND current price must be above both Supertrend lines (provides buffer).
    st_long_confirm = (
        short_st_up is True and long_st_up is True and
        current_price > short_st_val + FLOAT_TOLERANCE and
        current_price > long_st_val + FLOAT_TOLERANCE
    )
    # 2. Volume Confirmation: Recent volume must be significantly higher than average.
    vol_confirm = volume_ratio > conf.volume_spike_threshold

    # 3. Order Book Confirmation: More volume on the bid side than ask side (above threshold).
    ob_long_confirm = ob_pressure > conf.ob_pressure_threshold

    # Final Long Entry Signal: All conditions must be met
    long_entry_signal = st_long_confirm and vol_confirm and ob_long_confirm

    # --- Short Signal Conditions ---
    # 1. Trend Confirmation: Both Supertrends must be bearish (is_uptrend = False)
    #    AND current price must be below both Supertrend lines.
    st_short_confirm = (
        short_st_up is False and long_st_up is False and
        current_price < short_st_val - FLOAT_TOLERANCE and
        current_price < long_st_val - FLOAT_TOLERANCE
    )
    # 2. Volume Confirmation: Same volume spike needed for conviction. (vol_confirm reused)

    # 3. Order Book Confirmation: More volume on the ask side (low bid pressure).
    #    Bid Pressure < 1 - Threshold
    ob_short_confirm = ob_pressure < (1.0 - conf.ob_pressure_threshold)

    # Final Short Entry Signal: All conditions must be met
    short_entry_signal = st_short_confirm and vol_confirm and ob_short_confirm

    # Log signal components for debugging/transparency
    logger.debug(
        f"Signal Components: ST_LongOK={st_long_confirm} (ShortUp={short_st_up}, LongUp={long_st_up}), "
        f"VolOK={vol_confirm} (Ratio={volume_ratio:.2f} > {conf.volume_spike_threshold}), "
        f"OB_LongOK={ob_long_confirm} (Pressure={ob_pressure:.3f} > {conf.ob_pressure_threshold}), "
        f"ST_ShortOK={st_short_confirm} (ShortUp={short_st_up}, LongUp={long_st_up}), " # Add short ST confirm state
        f"OB_ShortOK={ob_short_confirm} (Pressure={ob_pressure:.3f} < {1.0 - conf.ob_pressure_threshold:.3f})"
    )
    logger.info(
        f"{log_prefix}Final Signals: {Style.BRIGHT}Long Entry={Fore.GREEN if long_entry_signal else Fore.WHITE}{long_entry_signal}{Style.RESET_ALL}, "
        f"{Style.BRIGHT}Short Entry={Fore.RED if short_entry_signal else Fore.WHITE}{short_entry_signal}{Style.RESET_ALL}"
    )

    # --- 5. Decision Making & Execution ---
    logger.info(f"{log_prefix}Executing trading decisions...")
    action_taken_this_cycle = False  # Flag to track if an order was attempted/simulated

    # ==================================
    # === Case 1: No Open Position ===
    # ==================================
    if position_side == PositionSide.NONE:
        if long_entry_signal:
            logger.info(
                f"{log_prefix}{Fore.YELLOW}{Style.BRIGHT}ACTION:{Style.RESET_ALL} Initiate LONG entry for {conf.symbol}."
            )
            # Place entry order using the calculated ATR and current price estimate
            # Current_atr is confirmed not None here
            order = place_entry_order(
                exch, conf, conf.symbol, Side.BUY, current_atr, current_price
            )
            action_taken_this_cycle = True
            if order:
                if conf.dry_run:
                    # Update simulated position state using info from the mock order
                    dry_run_position["side"] = PositionSide.LONG
                    dry_run_position["amount"] = safe_float(order.get("amount", 0.0))
                    dry_run_position["entry_price"] = safe_float(order.get("average", current_price))
                    logger.info(
                        f"DRY RUN: Simulated LONG entry. New state: Side={dry_run_position['side'].value}, Amount={dry_run_position['amount']:.8f}, Entry={dry_run_position['entry_price']:{price_format}}"
                    )
                else:
                    # Send SMS only on successful live order
                    send_sms(
                        f"✅ ({conf.symbol}) LONG Entry executed @ ~{current_price:{price_format}}. SL/TP set. ID: {order.get('id')}"
                    )
            else:
                logger.error(f"{log_prefix}Failed to execute LONG entry order.")
                # SMS for failure already sent by place_order functions if applicable

        elif short_entry_signal:
            logger.info(
                f"{log_prefix}{Fore.YELLOW}{Style.BRIGHT}ACTION:{Style.RESET_ALL} Initiate SHORT entry for {conf.symbol}."
            )
            order = place_entry_order(
                exch, conf, conf.symbol, Side.SELL, current_atr, current_price
            )
            action_taken_this_cycle = True
            if order:
                if conf.dry_run:
                    # Update simulated position state
                    dry_run_position["side"] = PositionSide.SHORT
                    dry_run_position["amount"] = safe_float(order.get("amount", 0.0))
                    dry_run_position["entry_price"] = safe_float(order.get("average", current_price))
                    logger.info(
                        f"DRY RUN: Simulated SHORT entry. New state: Side={dry_run_position['side'].value}, Amount={dry_run_position['amount']:.8f}, Entry={dry_run_position['entry_price']:{price_format}}"
                    )
                else:
                    send_sms(
                        f"✅ ({conf.symbol}) SHORT Entry executed @ ~{current_price:{price_format}}. SL/TP set. ID: {order.get('id')}"
                    )
            else:
                logger.error(f"{log_prefix}Failed to execute SHORT entry order.")
                # SMS for failure already sent
        else:
            logger.info(f"{log_prefix}No entry signal and no position. Holding flat.")

    # ==================================
    # === Case 2: Holding LONG Position ===
    # ==================================
    elif position_side == PositionSide.LONG:
        # --- Check for Reversal Signal (Short Entry Signal) ---
        if short_entry_signal:
            logger.info(
                f"{log_prefix}{Fore.YELLOW}{Style.BRIGHT}ACTION:{Style.RESET_ALL} Reversal signal detected (LONG -> SHORT) for {conf.symbol}."
            )
            logger.info(
                f"{log_prefix}--> Step 1: Closing existing LONG position ({position_amount:.8f} {conf.symbol})."
            )
            close_order = close_position(
                exch, conf, conf.symbol, position_side, position_amount
            )
            action_taken_this_cycle = True

            # Only proceed to open SHORT if close was successful (or simulated)
            if close_order:
                if conf.dry_run:
                    # Reset simulated position after close
                    dry_run_position = {
                        "side": PositionSide.NONE,
                        "amount": 0.0,
                        "entry_price": 0.0,
                    }
                    logger.info("DRY RUN: Simulated LONG position closed for reversal.")
                else:
                    # Send SMS confirmation of close
                    send_sms(
                        f"☑️ ({conf.symbol}) Closed LONG position for reversal. ID: {close_order.get('id')}"
                    )
                    # Optional wait for exchange state update after live close
                    wait_seconds = DEFAULT_POSITION_CLOSE_WAIT_SECONDS
                    logger.info(
                        f"Waiting {wait_seconds}s for close order settlement before opening SHORT..."
                    )
                    time.sleep(wait_seconds)
                    # Re-fetch price after waiting using ticker for faster update
                    logger.info("Refreshing price after wait...")
                    refreshed_price = current_price # Default to previous price if refresh fails
                    try:
                        if exch:
                            params = {'category': 'linear'}
                            try:
                                if exch.market(conf.symbol).get('inverse'): params['category'] = 'inverse'
                            except Exception: pass
                            ticker = exch.fetch_ticker(conf.symbol, params=params)
                            ticker_price_after_close = safe_float(ticker.get("last"), None)
                            if ticker_price_after_close is not None and ticker_price_after_close > FLOAT_TOLERANCE:
                                refreshed_price = ticker_price_after_close
                                logger.info(f"Refreshed price after wait (ticker): {refreshed_price:{price_format}}")
                            else:
                                logger.warning("Could not fetch valid ticker price after close, using previous price estimate for SHORT entry.")
                        else: # Should not happen if not dry run, but safety check
                            logger.warning("Exchange object missing unexpectedly after close, using previous price.")
                    except Exception as ticker_e:
                        logger.warning(f"Could not fetch ticker after close: {ticker_e}. Using previous price estimate for SHORT entry.")
                    current_price = refreshed_price # Update price for the new entry

                # --- Attempt to Open New SHORT Position ---
                logger.info(
                    f"{log_prefix}--> Step 2: Attempting to open new SHORT position."
                )
                # Current_atr is still valid from the start of the cycle
                new_short_order = place_entry_order(
                    exch, conf, conf.symbol, Side.SELL, current_atr, current_price
                )
                if new_short_order:
                    if conf.dry_run:
                        # Update simulated state for the new short position
                        dry_run_position["side"] = PositionSide.SHORT
                        dry_run_position["amount"] = safe_float(new_short_order.get("amount", 0.0))
                        dry_run_position["entry_price"] = safe_float(new_short_order.get("average", current_price))
                        logger.info(
                            f"DRY RUN: Simulated SHORT entry after reversal. New state: Side={dry_run_position['side'].value}, Amount={dry_run_position['amount']:.8f}, Entry={dry_run_position['entry_price']:{price_format}}"
                        )
                    else:
                        send_sms(
                            f"🔄 ({conf.symbol}) Reversed LONG to SHORT @ ~{current_price:{price_format}}. SL/TP set. ID: {new_short_order.get('id')}"
                        )
                else:
                    logger.error(
                        f"{log_prefix}Failed to open SHORT position after closing LONG during reversal. Bot is now FLAT."
                    )
                    # SMS for failure already sent by place_order functions if applicable
                    # Update dry run state to flat if simulation failed entry
                    if conf.dry_run:
                        dry_run_position = {
                            "side": PositionSide.NONE, "amount": 0.0, "entry_price": 0.0
                        }

            else:  # close_order failed
                logger.error(
                    f"{log_prefix}❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to close LONG position, cannot execute reversal to SHORT. Position remains LONG."
                )
                # Critical alert SMS already sent by close_position failure

        # --- Add other Exit Conditions Here (e.g., Supertrend flip without full reversal signal) ---
        # Example: Exit if the longer-term Supertrend flips against the position
        elif long_st_up is False:  # Check if the longer Supertrend flipped to DOWN
            logger.info(
                f"{log_prefix}{Fore.YELLOW}INFO:{Style.RESET_ALL} Holding LONG, but Long ST ({conf.long_st_period}) flipped to DOWN. Trend weakening."
            )
            # --- Implement Optional Exit Logic (Commented out by default) ---
            # Add a config option: EXIT_ON_LONG_ST_FLIP = False
            # if getattr(conf, 'exit_on_long_st_flip', False):
            #      logger.info(f"{log_prefix}{Fore.YELLOW}{Style.BRIGHT}ACTION:{Style.RESET_ALL} Exiting LONG position due to Long Supertrend ({conf.long_st_period}) flip.")
            #      exit_order = close_position(exch, conf, conf.symbol, position_side, position_amount)
            #      action_taken_this_cycle = True
            #      if exit_order:
            #          if conf.dry_run:
            #               dry_run_position = {"side": PositionSide.NONE, "amount": 0.0, "entry_price": 0.0}
            #               logger.info(f"DRY RUN: Simulated LONG exit due to Long ST flip.")
            #          else:
            #               send_sms(f"⚠️ ({conf.symbol}) Exited LONG due to Long ST flip. ID: {exit_order.get('id')}")
            #      else:
            #           logger.error(f"{log_prefix}❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to close LONG position based on Long ST flip exit signal.")
            # --- End Optional Exit Logic ---
        else:
            logger.info(
                f"{log_prefix}Holding LONG position. Conditions remain favorable or no exit/reversal signal."
            )

    # ===================================
    # === Case 3: Holding SHORT Position ===
    # ===================================
    elif position_side == PositionSide.SHORT:
        # --- Check for Reversal Signal (Long Entry Signal) ---
        if long_entry_signal:
            logger.info(
                f"{log_prefix}{Fore.YELLOW}{Style.BRIGHT}ACTION:{Style.RESET_ALL} Reversal signal detected (SHORT -> LONG) for {conf.symbol}."
            )
            logger.info(
                f"{log_prefix}--> Step 1: Closing existing SHORT position ({position_amount:.8f} {conf.symbol})."
            )
            close_order = close_position(
                exch, conf, conf.symbol, position_side, position_amount
            )
            action_taken_this_cycle = True

            # Only proceed to open LONG if close was successful (or simulated)
            if close_order:
                if conf.dry_run:
                    # Reset simulated position after close
                    dry_run_position = {
                        "side": PositionSide.NONE, "amount": 0.0, "entry_price": 0.0
                    }
                    logger.info("DRY RUN: Simulated SHORT position closed for reversal.")
                else:
                    # Send SMS confirmation of close
                    send_sms(
                        f"☑️ ({conf.symbol}) Closed SHORT position for reversal. ID: {close_order.get('id')}"
                    )
                    # Optional wait
                    wait_seconds = DEFAULT_POSITION_CLOSE_WAIT_SECONDS
                    logger.info(
                        f"Waiting {wait_seconds}s for close order settlement before opening LONG..."
                    )
                    time.sleep(wait_seconds)
                    # Refresh price
                    logger.info("Refreshing price after wait...")
                    refreshed_price = current_price # Default to previous price if refresh fails
                    try:
                        if exch:
                            params = {'category': 'linear'}
                            try:
                                if exch.market(conf.symbol).get('inverse'): params['category'] = 'inverse'
                            except Exception: pass
                            ticker = exch.fetch_ticker(conf.symbol, params=params)
                            ticker_price_after_close = safe_float(ticker.get("last"), None)
                            if ticker_price_after_close is not None and ticker_price_after_close > FLOAT_TOLERANCE:
                                refreshed_price = ticker_price_after_close
                                logger.info(f"Refreshed price after wait (ticker): {refreshed_price:{price_format}}")
                            else:
                                logger.warning("Could not fetch valid ticker price after close, using previous price estimate for LONG entry.")
                        else:
                            logger.warning("Exchange object missing unexpectedly after close, using previous price.")
                    except Exception as ticker_e:
                        logger.warning(f"Could not fetch ticker after close: {ticker_e}. Using previous price estimate for LONG entry.")
                    current_price = refreshed_price # Update price for the new entry

                # --- Attempt to Open New LONG Position ---
                logger.info(
                    f"{log_prefix}--> Step 2: Attempting to open new LONG position."
                )
                new_long_order = place_entry_order(
                    exch, conf, conf.symbol, Side.BUY, current_atr, current_price
                )
                if new_long_order:
                    if conf.dry_run:
                        # Update simulated state for the new long position
                        dry_run_position["side"] = PositionSide.LONG
                        dry_run_position["amount"] = safe_float(new_long_order.get("amount", 0.0))
                        dry_run_position["entry_price"] = safe_float(new_long_order.get("average", current_price))
                        logger.info(
                            f"DRY RUN: Simulated LONG entry after reversal. New state: Side={dry_run_position['side'].value}, Amount={dry_run_position['amount']:.8f}, Entry={dry_run_position['entry_price']:{price_format}}"
                        )
                    else:
                        send_sms(
                            f"🔄 ({conf.symbol}) Reversed SHORT to LONG @ ~{current_price:{price_format}}. SL/TP set. ID: {new_long_order.get('id')}"
                        )
                else:
                    logger.error(
                        f"{log_prefix}Failed to open LONG position after closing SHORT during reversal. Bot is now FLAT."
                    )
                    if conf.dry_run:
                        dry_run_position = {
                            "side": PositionSide.NONE, "amount": 0.0, "entry_price": 0.0
                        }

            else:  # close_order failed
                logger.error(
                    f"{log_prefix}❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to close SHORT position, cannot execute reversal to LONG. Position remains SHORT."
                )
                # Critical alert SMS already sent by close_position failure

        # --- Add other Exit Conditions Here (e.g., Supertrend flip) ---
        # Example: Exit if the longer-term Supertrend flips against the position
        elif long_st_up is True:  # Check if the longer Supertrend flipped to UP
            logger.info(
                f"{log_prefix}{Fore.YELLOW}INFO:{Style.RESET_ALL} Holding SHORT, but Long ST ({conf.long_st_period}) flipped to UP. Trend weakening."
            )
            # --- Implement Optional Exit Logic (Commented out by default) ---
            # if getattr(conf, 'exit_on_long_st_flip', False):
            #      logger.info(f"{log_prefix}{Fore.YELLOW}{Style.BRIGHT}ACTION:{Style.RESET_ALL} Exiting SHORT position due to Long Supertrend ({conf.long_st_period}) flip.")
            #      exit_order = close_position(exch, conf, conf.symbol, position_side, position_amount)
            #      action_taken_this_cycle = True
            #      if exit_order:
            #          if conf.dry_run:
            #               dry_run_position = {"side": PositionSide.NONE, "amount": 0.0, "entry_price": 0.0}
            #               logger.info(f"DRY RUN: Simulated SHORT exit due to Long ST flip.")
            #          else:
            #               send_sms(f"⚠️ ({conf.symbol}) Exited SHORT due to Long ST flip. ID: {exit_order.get('id')}")
            #      else:
            #           logger.error(f"{log_prefix}❌ {Fore.RED}{Style.BRIGHT}FAILED{Style.RESET_ALL} to close SHORT position based on Long ST flip exit signal.")
            # --- End Optional Exit Logic ---
        else:
            logger.info(
                f"{log_prefix}Holding SHORT position. Conditions remain favorable or no exit/reversal signal."
            )

    # --- Cycle End Logging ---
    if not action_taken_this_cycle:
        if position_side == PositionSide.NONE:
            logger.info(
                f"{log_prefix}No action taken this cycle (No signal, No position)."
            )
        else:
            logger.info(
                f"{log_prefix}No action taken this cycle (Holding {position_side.value}, No exit/reversal signal)."
            )

    logger.info(
        f"{log_prefix}{Fore.CYAN}{Style.BRIGHT}--- Trade Logic Cycle End for {conf.symbol} ---{Style.RESET_ALL}"
    )
    return True  # Indicate cycle completed without critical internal failure


# --- Main Execution Loop ---
if __name__ == "__main__":
    run_count = 0
    error_streak = 0  # Count consecutive cycles with errors

    try:
        # Initial startup messages
        logger.info(
            f"{Fore.GREEN}{Style.BRIGHT}🚀 Awakening Pyrmethus Bot for {config.symbol}...{Style.RESET_ALL}"
        )
        logger.info(
            f"Parameters: Timeframe={config.timeframe}, Leverage={config.leverage}x, "
            f"Risk={config.risk_per_trade * 100:.1f}%, SL Mult={config.sl_atr_mult}, TP Mult={config.tp_atr_mult}, "
            f"DryRun={config.dry_run}, LogLevel={config.logging_level}, LoopSleep={config.loop_sleep_seconds}s"
        )
        logger.info(
            f"Indicators: ShortST(P={config.short_st_period}, M={config.st_multiplier}), "
            f"LongST(P={config.long_st_period}, M={config.st_multiplier}), VolRatioThresh={config.volume_spike_threshold:.2f}, "
            f"OBPressureThresh={config.ob_pressure_threshold:.2f} (Long > T | Short < {1.0 - config.ob_pressure_threshold:.2f})"
        )
        # Make stateless warning more prominent at startup
        logger.warning(
            f"{Fore.RED}{Style.BRIGHT}####################################################################"
        )
        logger.warning(
            f"# CRITICAL WARNING: Using STATELESS Supertrend calculation.         #"
        )
        logger.warning(
            f"# Signals can differ significantly from stateful versions (e.g., TV). #"
        )
        logger.warning(
            f"# VERIFY behavior thoroughly in dry run before live trading!       #"
        )
        logger.warning(
            f"####################################################################{Style.RESET_ALL}"
        )


        initial_message = (
            f"✅ Bot LIVE ({config.symbol} {config.timeframe}) started. Risk={config.risk_per_trade * 100:.1f}%, Lev={config.leverage}x."
            if not config.dry_run
            else f"DRY RUN: Bot DRY RUN ({config.symbol} {config.timeframe}) started."
        )
        logger.info(initial_message)
        # Send startup SMS only if live and enabled
        if not config.dry_run and config.sms_enabled:
            send_sms(initial_message)

        # --- Main Loop ---
        while True:
            run_count += 1
            logger.info(
                f"{Fore.BLUE}{Style.BRIGHT}===== Cycle {run_count} Start ({time.strftime('%Y-%m-%d %H:%M:%S')}) ====="
                + Style.RESET_ALL
            )
            start_time = time.time()
            cycle_successful = False  # Flag to track if trade_logic completed without internal critical errors

            try:
                # --- Exchange Health Check & Re-initialization ---
                # In live mode, ensure exchange object is valid. Try to re-setup if it's None.
                if exchange is None and not config.dry_run:
                    logger.warning(
                        "Exchange object is None at start of cycle. Attempting to re-initialize..."
                    )
                    # Wait briefly before re-initializing to avoid spamming setup on rapid failures
                    time.sleep(DEFAULT_API_RETRY_DELAY)
                    exchange = setup_exchange(config)  # Attempt to re-create
                    if exchange is None:
                        logger.critical(
                            "🛑 Re-initialization failed. Stopping bot as exchange connection is lost."
                        )
                        send_sms(
                            f"Bot CRITICAL ERROR ({config.symbol}): Exchange re-initialization failed. Bot stopped."
                        )
                        # Directly break loop without increasing error streak limit trigger
                        # as this is a fundamental failure.
                        break
                    else:
                        logger.info("✅ Exchange re-initialized successfully.")
                        # Attempt to set leverage again after re-initialization
                        if not set_symbol_leverage(
                            exchange, config.symbol, config.leverage, config
                        ):
                            logger.critical(
                                f"🛑 Could not set leverage for {config.symbol} after re-initialization. Stopping bot for safety."
                            )
                            send_sms(
                                f"Bot CRITICAL ERROR ({config.symbol}): Failed to set leverage after re-init. Bot stopped."
                            )
                            break  # Exit if leverage cannot be confirmed after re-init
                        else:
                            logger.info(
                                "✅ Leverage confirmed after re-initialization."
                            )

                # --- Execute Core Logic ---
                # Pass the potentially re-initialized exchange object
                cycle_successful = trade_logic(exchange, config)

                # --- Reset error counter on successful cycle execution ---
                if cycle_successful:
                    if error_streak > 0:
                        logger.info(
                            f"✅ Cycle {run_count} completed successfully. Resetting error streak (was {error_streak})."
                        )
                        # Optionally send recovery message
                        # if error_streak >= 1 and config.sms_enabled and not config.dry_run:
                        #     send_sms(f"✅ Bot ({config.symbol}) recovered after {error_streak} error cycle(s).")
                    error_streak = 0
                else:
                    # trade_logic returned False, indicating an internal critical error within the logic itself
                    logger.error(
                        f"Trade logic cycle {run_count} reported failure. Incrementing error streak."
                    )
                    error_streak += 1

            # --- Handle Specific Exceptions during the cycle ---
            except KeyboardInterrupt:
                logger.info(
                    f"{Fore.YELLOW}{Style.BRIGHT}\n🛑 Shutdown requested by user (Ctrl+C). Exiting gracefully...{Style.RESET_ALL}"
                )
                # Send SMS even if dry run was stopped by user, if SMS was initially intended
                if config.sms_enabled or config._termux_sms_available: # Check if SMS was possible at all
                    send_sms(f"⏹️ Bot ({config.symbol}) stopped by user.")
                break  # Exit loop cleanly

            except ccxt.AuthenticationError as e:
                # This shouldn't happen here if initial setup worked, but API keys might get invalidated. Critical.
                logger.critical(
                    f"🚫 CRITICAL: Authentication failed during operation: {e}. Check API keys immediately. Stopping bot."
                )
                send_sms(
                    f"Bot CRITICAL ERROR ({config.symbol}): Authentication Failed during runtime. Bot stopped."
                )
                break  # Exit loop immediately

            # Handle potentially recoverable exchange/network errors
            except (
                ccxt.ExchangeNotAvailable,
                ccxt.NetworkError,
                NewConnectionError,
                MaxRetryError,
                Urllib3TimeoutError,
                ccxt.RequestTimeout,
                ccxt.DDoSProtection,
            ) as e:
                logger.error(
                    f"🕸️ Recoverable Error in cycle {run_count}: {type(e).__name__} - {e}. Will retry after sleep."
                )
                error_streak += 1
                cycle_successful = False  # Mark cycle as having an error
                # Send SMS less frequently for these potentially transient issues
                if not config.dry_run and (error_streak == 1 or error_streak % 3 == 0): # Send on first occurrence and every 3rd time after
                    send_sms(
                        f"Bot WARNING ({config.symbol}): Recoverable error ({type(e).__name__}, Streak: {error_streak}). Retrying..."
                    )
                # If exchange connection failed, set exchange object to None to trigger re-init attempt next cycle
                if isinstance(e, (ccxt.ExchangeNotAvailable, ccxt.NetworkError, NewConnectionError, MaxRetryError, Urllib3TimeoutError, ccxt.RequestTimeout)):
                    logger.warning("Setting exchange object to None due to connection error. Will attempt re-init.")
                    exchange = None


            # Catch-all for unexpected errors in trade_logic or other parts of the loop
            except Exception as e:
                logger.exception(
                    f"💥 FATAL UNEXPECTED ERROR in main loop cycle {run_count}: {e}"
                )  # Includes stack trace
                error_streak += 1
                cycle_successful = False  # Mark cycle as having an error
                # Send SMS immediately for fatal errors
                send_sms(
                    f"Bot FATAL ERROR ({config.symbol}): {type(e).__name__} - {str(e)[:50]}... Check logs! Streak: {error_streak}"
                )

            # --- Stop Bot after too many consecutive errors ---
            if error_streak >= DEFAULT_CONSECUTIVE_ERROR_LIMIT:
                logger.critical(
                    f"🛑 Stopping bot after {error_streak} consecutive cycles with errors."
                )
                send_sms(
                    f"Bot CRITICAL ({config.symbol}): Stopping after {error_streak} consecutive errors. Needs review."
                )
                break  # Exit loop

            # --- Loop Sleep ---
            end_time = time.time()
            cycle_duration = end_time - start_time
            # Ensure sleep time is non-negative, respecting minimum sleep time
            sleep_time = max(
                DEFAULT_MINIMUM_SLEEP_SECONDS, conf.loop_sleep_seconds - cycle_duration
            )
            logger.info(
                f"Cycle {run_count} finished in {cycle_duration:.2f}s. Sleeping for {sleep_time:.2f} seconds... "
                f"{Style.DIM}(Next run approx: {time.strftime('%H:%M:%S', time.localtime(time.time() + sleep_time))}) (Error Streak: {error_streak}) (Press Ctrl+C to stop){Style.RESET_ALL}"
            )
            try:
                time.sleep(sleep_time)
            except KeyboardInterrupt:  # Allow stopping during sleep
                logger.info(
                    f"{Fore.YELLOW}{Style.BRIGHT}\n🛑 Shutdown requested during sleep. Exiting...{Style.RESET_ALL}"
                )
                if config.sms_enabled or config._termux_sms_available:
                    send_sms(f"⏹️ Bot ({config.symbol}) stopped by user.")
                break  # Exit loop

    except Exception as outer_e:
        # Catch errors during initial setup (before main loop) or unexpected exits
        logger.exception(
            f"💥 An unexpected critical error occurred outside the main loop: {outer_e}"
        )
        try: # Attempt to send SMS if possible
            # Check original config state for sms_enabled, as config object might be partially initialized
            # Use the config object if available, otherwise try checking env var directly (less reliable)
            sms_num = None
            sms_intended = False
            if 'config' in locals() and config is not None:
                 sms_num = config.sms_recipient_number
                 sms_intended = config.sms_enabled or config._termux_sms_available # Check if it was ever possible
            else:
                 sms_num = os.getenv("SMS_RECIPIENT_NUMBER")
                 sms_intended = os.getenv("SMS_ENABLED", "false").lower() in ("true", "1", "yes")

            if sms_intended and sms_num:
                # Use subprocess directly as send_sms might rely on initialized config state
                try:
                    subprocess.run(
                        [
                            "termux-sms-send", "-n", sms_num,
                            f"Bot CRITICAL FAILURE ({config.symbol if 'config' in locals() and config else 'N/A'}): Terminated unexpectedly outside main loop. Error: {str(outer_e)[:60]}",
                        ],
                        timeout=10, check=False, stderr=subprocess.PIPE, stdout=subprocess.PIPE, text=True
                    )
                    logger.info("Attempted to send final critical SMS.")
                except Exception as sms_sub_err:
                    logger.error(f"Subprocess SMS failed during critical exit: {sms_sub_err}")
            else:
                logger.info("SMS not configured or recipient missing, cannot send final alert.")
        except Exception as sms_fail_e:
            logger.error(f"Failed to attempt final critical SMS: {sms_fail_e}")
    finally:
        # Cleanup actions
        logger.info(
            f"{Fore.GREEN}{Style.BRIGHT}✨ Pyrmethus Bot shutdown sequence initiated. ✨{Style.RESET_ALL}"
        )
        # Optional: Attempt to close any open position on shutdown?
        # This is risky as API calls might fail during shutdown. Manual check is often safer.
        # Add a config option, e.g., CLOSE_ON_EXIT=False (Default to False)
        # if not config.dry_run and exchange and getattr(config, 'close_on_exit', False):
        #     try:
        #         logger.info("Attempting to check and close any open position before final exit (CLOSE_ON_EXIT=True)...")
        #         pos_side, pos_amount, _ = get_position(exchange, config.symbol)
        #         if pos_side != PositionSide.NONE and pos_amount > FLOAT_TOLERANCE:
        #             logger.warning(f"Found open {pos_side.value} position ({pos_amount}). Attempting emergency close.")
        #             # Use a direct call without retry here, as it's best effort on exit
        #             try:
        #                 close_side = Side.SELL if pos_side == PositionSide.LONG else Side.BUY
        #                 category = 'linear'
        #                 try:
        #                     if exchange.market(config.symbol).get('inverse'): category = 'inverse'
        #                 except Exception: pass
        #                 close_params = {'category': category, 'reduceOnly': True}
        #                 # Format amount using precision before sending
        #                 close_amount_str = exchange.amount_to_precision(config.symbol, pos_amount)
        #                 close_amount_float = safe_float(close_amount_str)
        #                 if close_amount_float > FLOAT_TOLERANCE:
        #                      logger.info(f"Placing emergency market close order: {close_side.value} {close_amount_str} {config.symbol}")
        #                      exchange.create_order(config.symbol, 'market', close_side.value, close_amount_float, params=close_params)
        #                      logger.info("Emergency close market order placed (best effort). Verify on exchange.")
        #                 else:
        #                      logger.error("Formatted close amount is too small, cannot place emergency order.")
        #             except Exception as close_e:
        #                 logger.error(f"Failed to place emergency close order: {close_e}. Manual check required!")
        #         else:
        #             logger.info("No open position found to close.")
        #     except Exception as close_check_err:
        #         logger.error(f"Error during shutdown position check/close: {close_check_err}. Manual check required!")

        logger.info(
            f"{Fore.GREEN}{Style.BRIGHT}✨ Pyrmethus Bot shutdown complete. ✨{Style.RESET_ALL}"
        )
        logging.shutdown()  # Ensure all log handlers are closed and flushed properly
        sys.exit(0)  # Explicitly exit with code 0 for success/clean shutdown

```

**Explanation of Key Upgrades and Changes:**

1.  **Error Handling & Robustness:**
    *   **`place_order_with_retry`:** Significantly improved. Now distinguishes between transient errors (network, rate limits - retried) and non-retriable errors (InvalidOrder, InsufficientFunds, specific Bybit codes like risk limits, permission errors, parameter errors - fail immediately). Added validation for the order response structure.
    *   **Helper Functions (`fetch_ohlcv`, `get_position`, `get_balance`, etc.):** Added more specific error handling (e.g., checking for valid data lengths, formats, specific API error messages/codes like "position not found"). Return values are more consistent on failure. `safe_float` is used more consistently.
    *   **`setup_exchange`:** Added checks for time difference, more detailed symbol validation (checking `swap` flag, listing alternatives), handles more network/exchange error types during setup. Added `ccxt.RequestTimeout`.
    *   **`set_symbol_leverage`:** Heavily refactored to use the correct V5 endpoint (`private_post_v5_position_set_leverage`), determine `category` (linear/inverse), check leverage limits, and handle many specific Bybit error codes/messages related to leverage setting (e.g., already set, margin mode required, account type issues). Failure is now treated as critical, stopping the bot.
    *   **`get_position`:** Refactored for V5. Determines `category`. Parses V5 `info` fields first (size, side, avgPrice), falls back to CCXT standard fields. Handles potential Hedge Mode detection with a warning. Parses specific "no position" errors/codes.
    *   **`get_balance`:** Refactored for V5 UTA. Tries different `accountType` parameters (`UNIFIED`, `CONTRACT`). Parses V5 `info` structure (`totalEquity`, specific coin `equity`). Falls back gracefully to standard CCXT `total` and `free`/`used` fields.
    *   **Main Loop:** Added `error_streak` counter and `DEFAULT_CONSECUTIVE_ERROR_LIMIT` to stop the bot after too many consecutive failures. Attempts to re-initialize the `exchange` object if it becomes `None` due to connection errors. Checks leverage again after re-initialization. Handles `KeyboardInterrupt` more gracefully during sleep. Sets `exchange = None` on certain network errors to trigger re-init attempt.

2.  **Stateless Supertrend Warning:** Made the warning in the console output and in the `calculate_supertrend` docstring/logs much more prominent using `Style.BRIGHT` and `Fore.RED` to emphasize the risks and potential inaccuracies. Added a suggestion to use `pandas-ta`. The *calculation logic itself remains stateless* but the warnings are stronger.

3.  **Dry Run Simulation:**
    *   Improved mock data generation in `fetch_ohlcv` for slightly more realistic price action.
    *   Added mock slippage and fee calculation in `place_entry_order`'s simulated response.
    *   `close_position` simulation now tries to use a fetched ticker price for a more realistic close price estimate.
    *   Dry run position state (`dry_run_position`) is updated more consistently after simulated actions in `trade_logic`.

4.  **Configuration & Validation:**
    *   Improved `_format_symbol` to handle edge cases better and provide warnings.
    *   Added validation for `RISK_PER_TRADE` and `OB_PRESSURE_THRESHOLD` to be strictly between 0 and 1.
    *   Improved `_check_sms_capabilities` with a longer timeout and better error handling.
    *   Added checks for market limits (`min/max amount`, `min/max cost`) in `place_entry_order` and `close_position` using CCXT market data. Added clamping/error messages if limits are violated.

5.  **API Interaction (Bybit V5):**
    *   Explicitly added V5 endpoint hints (`fetchPositions`, `fetchBalance`, etc.) in `setup_exchange` options for potentially better CCXT routing, although CCXT often handles this automatically.
    *   Used specific V5 parameters where necessary (e.g., `category`, `reduceOnly`, `stopLoss`/`takeProfit` strings).
    *   Leverage setting now uses the correct V5 method.
    *   Added `category` parameter to relevant `fetch_` calls (`fetch_positions`, `fetch_ticker`, `fetch_order_book`, `fetch_ohlcv`) where applicable for V5.

6.  **Logging & Readability:**
    *   Improved color highlighting in `ColorizingStreamHandler` for `FAILED`, `CRITICAL`, `FATAL`.
    *   Added more `logger.debug` statements for detailed tracing.
    *   Suppressed noisy logs from underlying libraries (`ccxt`, `urllib3`, `dotenv`).
    *   Used `contextlib.suppress` for cleaner handling of non-critical exceptions (e.g., getting display precision).
    *   Added `math` import.
    *   Refined comments and docstrings.

7.  **SMS Notifications:**
    *   Added message sanitization and length limiting.
    *   Improved `subprocess.run` call with timeout, error checking (return code, stderr), and text mode.
    *   Added an `sms_failure_count` to disable SMS automatically after several consecutive failures.

8.  **Trading Logic (`trade_logic`):**
    *   Improved price fetching using ticker with fallback and sanity checks.
    *   Ensures all *essential* indicators are calculated before proceeding.
    *   Refined the reversal logic: close first, wait, *refresh price*, then open opposite.
    *   Added placeholder comments for potential "exit on indicator flip" logic (currently disabled).

This upgraded script should be more robust, handle errors more gracefully, interact more reliably with the Bybit V5 API via CCXT, provide better logging, and have a slightly more realistic dry run mode, while strongly warning about the limitations of the stateless Supertrend calculation. Remember to test thoroughly!
